<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithms</title>
    <url>/2022/08/14/Algorithms/</url>
    <content><![CDATA[<p>计算机算法（持续更新中）</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Big Data</title>
    <url>/2022/09/21/Big-Data/</url>
    <content><![CDATA[<p><img src="/2022/09/21/Big-Data/tcp-shakes-hands-three-times.png"></p>
]]></content>
      <categories>
        <category>Data Science</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network</title>
    <url>/2022/08/13/Computer-Network/</url>
    <content><![CDATA[<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，物理层(Physical)，数据链路层(Data Link)，网络层(Network)，传输层(Transport)，会话层(Session)，表示层(Presentation)，应用层(Application)：</p>
<p><img src="/2022/08/13/Computer-Network/osi-7-model.png" alt="OSI 七层模型"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。</p>
<p><img src="/2022/08/13/Computer-Network/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="osi七层模型2"></p>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP&#x2F;IP 四 层模型呢？</strong></p>
<p>的确，OSI七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP&#x2F;IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>关于 OSI 七层模型非常不错的总结图片！</p>
<p><img src="/2022/08/13/Computer-Network/osi-model-detail.png"></p>
<h2 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h2><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将TCP&#x2F;IP四层模型和OSI七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="/2022/08/13/Computer-Network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p>
<h3 id="应用层（Application-layer）"><a href="#应用层（Application-layer）" class="headerlink" title="应用层（Application layer）"></a>应用层（Application layer）</h3><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img src="/2022/08/13/Computer-Network/5971-2-7I1-20220111095024771-20220111201807861.png"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><img src="/2022/08/13/Computer-Network/application-layer-protocol.png" alt="应用层重要协议"></p>
<p>应用层常见协议总结，请看这篇文章：<a href="./application-layer-protocol.md">应用层常见协议总结（应用层）</a>。</p>
<h3 id="传输层（Transport-layer）"><a href="#传输层（Transport-layer）" class="headerlink" title="传输层（Transport layer）"></a>传输层（Transport layer）</h3><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>运输层主要使用以下两种协议：</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<p><img src="/2022/08/13/Computer-Network/transport-layer-protocol.png" alt="传输层重要协议"></p>
<h3 id="网络层（Network-layer）"><a href="#网络层（Network-layer）" class="headerlink" title="网络层（Network layer）"></a>网络层（Network layer）</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><img src="/2022/08/13/Computer-Network/nerwork-layer-protocol.png" alt="网络层重要协议"></p>
<p><strong>网络层常见协议</strong> ：</p>
<ul>
<li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li>
<li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li>
<li>……</li>
</ul>
<h3 id="网络接口层（Network-interface-layer）"><a href="#网络接口层（Network-interface-layer）" class="headerlink" title="网络接口层（Network interface layer）"></a>网络接口层（Network interface layer）</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<p><img src="/2022/08/13/Computer-Network/network-interface-layer-protocol.png" alt="网络接口层重要协议"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结一下每一层包含的协议和核心技术:</p>
<p><img src="/2022/08/13/Computer-Network/network-protocol-overview.png" alt="TCP/IP 各层协议概览"></p>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li>
<li>DHCP 协议（动态主机配置）</li>
<li>DNS 系统原理（域名系统）</li>
<li>FTP 协议（文件传输协议）</li>
<li>Telnet协议（远程登陆协议）</li>
<li>电子邮件协议等（SMTP、POP3、IMAP）</li>
<li>……</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议<ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议<ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP 协议（TCP&#x2F;IP 协议的基础，分为 IPv4 和 IPv6）</li>
<li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT 协议（网络地址转换协议）</li>
<li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li>
<li>……</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA&#x2F;CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
</ul>
<h3 id="网络分层的原因"><a href="#网络分层的原因" class="headerlink" title="网络分层的原因"></a>网络分层的原因</h3><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h4 id="TCP-与-UDP-的区别（重要）"><a href="#TCP-与-UDP-的区别（重要）" class="headerlink" title="TCP 与 UDP 的区别（重要）"></a>TCP 与 UDP 的区别（重要）</h4><ol>
<li><strong>是否面向连接</strong> ：TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接；UDP是无连接的，在传送数据之前不需要建立连接。</li>
<li><strong>是否是可靠传输</strong>：TCP提供可靠的传输服务，TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达；UDP尽最大努力交付，远地主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。UDP是无状态服务，简单来说就是不管发出去之后的事情了；TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h4><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h4 id="HTTP-基于-TCP-还是-UDP？"><a href="#HTTP-基于-TCP-还是-UDP？" class="headerlink" title="HTTP 基于 TCP 还是 UDP？"></a>HTTP 基于 TCP 还是 UDP？</h4><p><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</p>
<h4 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h4><p><strong>运行于 TCP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li>
<li><strong>POP3&#x2F;IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>……</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h4 id="建立连接-TCP三次握手"><a href="#建立连接-TCP三次握手" class="headerlink" title="建立连接 - TCP三次握手"></a>建立连接 - TCP三次握手</h4><p><img src="/2022/08/13/Computer-Network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<ol>
<li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq&#x3D;x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。</li>
<li>第二次握手:服务端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack&#x3D;x+1,随机产生一个值seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li>
<li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack&#x3D;y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了</li>
</ol>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>
</ul>
<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h4><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<blockquote>
<p>三次握手就能确认双发收发功能都正常，缺一不可。</p>
</blockquote>
<h4 id="断开连接-TCP四次挥手"><a href="#断开连接-TCP四次挥手" class="headerlink" title="断开连接 - TCP四次挥手"></a>断开连接 - TCP四次挥手</h4><ol>
<li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li>
<li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li>
<li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li>
<li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li>
</ol>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ&#x3D;X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ&#x3D;y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li>慢开始：<br>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。<br>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li>
<li>拥塞避免：<br>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li>
<li>快重传：<br>当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。<br>如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</li>
<li>快恢复：<br>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。<br>由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ul>
<h4 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h4><p>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p>
<h4 id="HTTP协议-HyperText-Transfer-Protocol"><a href="#HTTP协议-HyperText-Transfer-Protocol" class="headerlink" title="HTTP协议(HyperText Transfer Protocol)"></a>HTTP协议(HyperText Transfer Protocol)</h4><p>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session用于标记特定客户端信息，存在在服务器的一个文件里。一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</p>
<h4 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h4><ul>
<li>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。</li>
<li>Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</li>
</ul>
<h4 id="浏览器中输入一个网址后，具体发生了什么"><a href="#浏览器中输入一个网址后，具体发生了什么" class="headerlink" title="浏览器中输入一个网址后，具体发生了什么"></a>浏览器中输入一个网址后，具体发生了什么</h4><ol>
<li>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址</li>
<li>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接</li>
<li>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应</li>
<li>服务器处理请求，并返回给浏览器</li>
<li>根据HTTP是否开启长连接，进行TCP的挥手过程</li>
<li>浏览器根据收到的静态资源进行页面渲染</li>
</ol>
<h4 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h4><ul>
<li>物理层<br>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</li>
<li>数据链路层<br>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</li>
<li>网络层<br>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</li>
<li>传输层<br>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li>
</ul>
<blockquote>
<p>运输层主要使用以下两种协议<br>传输控制协议 TCP（Transmission Control Protocol）–提供面向连接的，可靠的数据传输服务。<br>用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</p>
</blockquote>
<ul>
<li>会话层<br>建立会话：身份验证，权限鉴定等；保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</li>
<li>表示层<br>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li>
<li>应用层<br>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</li>
</ul>
<h4 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h4><ul>
<li><p>数据链路层 (Data Link Layer)<br>实现相邻（Neighboring）网络实体间的数据传输<br>成帧（Framing）：从物理层的比特流中提取出完整的帧<br>错误检测与纠正：为提供可靠数据通信提供可能<br>物理地址（MAC address）：48位，理论上唯一网络标识，烧录在网卡，不便更改<br>流量控制，避免“淹没”（overwhelming）:当快速的发送端遇上慢速的接收端，接收端缓存溢出<br>共享信道上的访问控制（MAC）：同一个信道，同时传输信号。如同：同一个Wifi热点（AP）连接着多个无线用户（手机），则多个用户同时需要发送数据，如何控制发送顺序？</p>
</li>
<li><p>网络层 (Network Layer)<br>将数据包跨越网络从源设备发送到目的设备（host to host）<br>路由（Routing）：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由<br>路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息<br>服务质量（QoS）控制：处理网络拥塞、负载均衡、准入控制、保障延迟<br>异构网络互联：在异构编址和异构网络中路由寻址和转发</p>
</li>
<li><p>传输层 (Transport Layer)<br>将数据从源端口发送到目的端口（进程到进程）<br>网络层定位到一台主机（host），传输层的作用域具体到主机上的某一个进程<br>网络层的控制主要面向运营商，传输层为终端用户提供端到端的数据传输控制<br>两类模式：可靠的传输模式，或不可靠传输模式<br>可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等<br>不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等</p>
</li>
<li><p>会话层 (Session Layer)<br>利用传输层提供的服务，在应用程序之间建立和维持会话，并能使会话获得同步</p>
</li>
<li><p>表示层（Presentation Layer）<br>关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构<br>应用层（Application Layer）</p>
</li>
</ul>
<h4 id="媒体接入控制-MAC-Medium-Access-Control-子层"><a href="#媒体接入控制-MAC-Medium-Access-Control-子层" class="headerlink" title="媒体接入控制 MAC (Medium Access Control)子层"></a>媒体接入控制 MAC (Medium Access Control)子层</h4><blockquote>
<p>if config \       查看网络情况<br>ping      \      测试网络连通<br>netstat  \       显示网络状态信息<br>nslookup  \      可以指定查询的类型，可以查到DNS记录的生存时间还可以指定使用哪个DNS服务器进行解释<br>ipconfig &#x2F;all   显示本机TCP&#x2F;IP配置的详细信息</p>
</blockquote>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><ol start="5">
<li>IP和MAC地址的区别<br>IP地址是根据网络拓扑结构而分配的，mac是网络设备出厂就配置的，用于标识唯一的设备，更换网络场景，ip可以重新分配，mac不可更改。</li>
</ol>
]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Analysis</title>
    <url>/2022/09/01/Data-Analysis/</url>
    <content><![CDATA[<h3 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h3><p>定义: 通过各个维度对用户或者产品特征属性的刻画，并对这些特征分析统计挖掘潜在价值信息。完美地抽象出一个用户的信息全貌，可以看作企业应用大数据的根基。用户画像使用标签来量化用户特征属性，达到描述用户的目的。用户画像是对现实世界中的用户进行建模。用户画像是描述用户的数据， 是符合特定业务需求的对用户的形式化描述。<br>用户画像，即用户信息标签化。企业通过收集与分析消费者个人属性、社会属性、生活习惯、消费行为等主要信息的数据之后，完美地抽象出一个用户的商业全貌。<br>用户画像为企业提供了足够的信息基础，能够帮助企业快速找到精准用户群体以及精准用户需求等更为广泛的反馈信息，来进行各种精准营销。<br>分析的维度：可以按照人口属性和产品行为属性进行综合分析。<br>    人口属性：地域、年龄、性别、文化、职业、收入、生活习惯、消费习惯等；<br>    产品行为属性：产品类别、活跃频率、产品喜好、产品驱动、使用习惯、产品消费等。</p>
<h3 id="RFM模型"><a href="#RFM模型" class="headerlink" title="RFM模型"></a>RFM模型</h3><p>R——最后交易距离当前天数（Recency）<br>F——累计交易次数（Frequency）<br>M——累计交易金额（Monetary）</p>
<p><strong>模型应用</strong><br>可用于有关重要客户筛选场景中。针对不同的客户制定相应的营销策略。<br>M：消费越多，用户价值越高，越应该重点关注。<br>R：离得越远，用户越有流失可能，越应该唤醒用户。<br>F：频次越低，越需要用一次性手段（比如促销、赠礼），频次越高，越可以用持续性手段（积分）来维护</p>
<blockquote>
<p>RFM的缺点是很明显的：它仅仅考虑了用户的行为数量，没有考虑用户在干什么。比如用RFM考察用户消费，就少了一个关键内容：用户买的是啥。同样的RFM数值，可能情况完全不一样</p>
</blockquote>
<h3 id="5W2H模型"><a href="#5W2H模型" class="headerlink" title="5W2H模型"></a>5W2H模型</h3><p>为什么（Why）、什么事（What）、谁（Who）、什么时候（When）、什么地方（Where）、如何做（How）、什么价格（How much)，主要用于用户行为分析、业务问题专题分析营销活动</p>
<p><strong>模型解释</strong><br>Why：用户为什么要买？产品的吸引点在哪里？<br>What：用户主要购买的产品是哪些———产品销量获取<br>Who：用户特征：性别构成、年龄分布、地域分布、学历分布、收入分布、注册时间<br>When：购买时间分布、购买间隔分布<br>Where：买渠道，例如：官网、app、天猫旗舰店、京东、苏宁、线下线上代理商<br>How：用户通过什么方式、渠道购买？<br>How much：价格段销量分布（用户更容易接受那个价位）</p>
<p><strong>模型应用</strong><br>模型是一种定律、是一种原理、也是一种流程、更是一种工具，被广泛运用于企业管理和日常工作学习之中、当然也可以对营销活动或者其它行为的分解。个人认为是一种缜密的思维逻辑。</p>
<h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><ol>
<li>数据仓库的定义</li>
</ol>
<ul>
<li>数据仓库是一个数据集合</li>
<li>数据仓库是一个为业务决策提供数据支持的数据集合</li>
<li>数据仓库是通过监控业务流程的形式为业务决策提供数据支持的数据集合</li>
</ul>
<ol start="2">
<li>数据仓库的特征</li>
</ol>
<ul>
<li><p>面向主题<br>面向事务性问题进行数据操作<br>例如：数据仓库对口市场部，提供业务支持<br>相关主题<br>人：客户基本信息，客户标签，销售人员业绩等<br>货：存货预测，资源分配，产品推陈出新等<br>场：社会环境，地域趋势，政策变动等</p>
</li>
<li><p>集成性<br>数据由不同的数据库经过加工处理，整合。关键是消除增提上数据的不一致性，统一口径，保证数据仓库内的信息是企业内部一致的全局信息</p>
</li>
<li><p>相对稳定性<br>关系型数据库相对于操作型数据库而言<br>数据仓库内的数据时效性不如操作型数据库，数据保留的更为长久，并且大概率是数据操作为查询语句操作，需要谨慎操作修改和删除语句，但是需要定期（日，周，月，季，年）做更新</p>
</li>
<li><p>历史变动<br>占用较大空间保留下来的数据，一定程度上可以反映活动效果等随着时间变化带来的影响，可以为业务提供相应的定量分析和预测</p>
</li>
</ul>
<ol start="3">
<li>数据仓库的终极目标<br>准确并且及时的为信息使用者提供数据决策支持</li>
</ol>
<h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><h4 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h4><p>Pandas中使用to_datetime()方法将文本格式转换为日期格式</p>
<h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><ol>
<li>可以直接删除</li>
<li>替换法或插值法</li>
<li>替换法有均值替换、前向、后向替换和常数替换</li>
</ol>
<h4 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h4><ol>
<li>指那些偏离正常范围的值，不是错误值</li>
<li>异常值出现频率低，但又会对实际项目分析造成偏差</li>
<li>异常值一般用箱线图（分位差法）或分布图（标准差法）来判断</li>
<li>异常值往往采取盖帽法或数据离散化</li>
</ol>
<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3>]]></content>
      <categories>
        <category>Data Science</category>
      </categories>
      <tags>
        <tag>Data Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Structures</title>
    <url>/2022/08/14/Data-Structures/</url>
    <content><![CDATA[<p>数据结构（持续更新中）</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Mining</title>
    <url>/2022/08/12/Data-Mining/</url>
    <content><![CDATA[<p>典型的机器学习方法包括： <strong>决策树方法、人工神经网络、支持向量机、正则化</strong> 方法。其他常见的预测方法还有 <strong>近邻法、朴素贝叶斯</strong> （属于统计学习方法）等。</p>
<h4 id="1-回归"><a href="#1-回归" class="headerlink" title="1. 回归"></a>1. 回归</h4><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h4><span id="more"></span>
<h4 id="3-聚类分析"><a href="#3-聚类分析" class="headerlink" title="3. 聚类分析"></a>3. 聚类分析</h4><h4 id="4-关联和相关分析"><a href="#4-关联和相关分析" class="headerlink" title="4. 关联和相关分析"></a>4. 关联和相关分析</h4><p>关联规则挖掘属于无监督学习方法。</p>
<h4 id="5-异常值分析"><a href="#5-异常值分析" class="headerlink" title="5. 异常值分析"></a>5. 异常值分析</h4><h4 id="6-CRISP-DM-模型"><a href="#6-CRISP-DM-模型" class="headerlink" title="6. CRISP-DM 模型"></a>6. CRISP-DM 模型</h4><ul>
<li>商业理解(Business understanding)：商业理解阶段应算是数据挖掘中最重要的一个部分，在这个阶段里我们需要明确商业目标、评估商业环境、确定挖掘目标以及产生一个项目计划。</li>
<li>数据理解(Data understanding)：数据是我们挖掘过程的“原材料”，在数据理解过程中我们要知道都有些什么数据，这些数据的特征是什么，可以通过对数据的描述性分析得到数据的特点。</li>
<li>数据准备(Date preparation)：在数据准备阶段我们需要对数据作出选择、清洗、重建、合并等工作。选出要进行分析的数据，并对不符合模型输入要求的数据进行规范化操作。</li>
<li>建模(Modeling)：建模过程也是数据挖掘中一个比较重要的过程。我们需要根据分析目的选出适合的模型工具，通过样本建立模型并对模型进行评估。</li>
<li>模型评估(Evaluation)：并不是每一次建模都能与我们的目的吻合，评价阶段旨在对建模结果进行评估，对效果较差的结果我们需要分析原因，有时还需要返回前面的步骤对挖掘过程重新定义。</li>
<li>结果部署(Deployment)：这个阶段是用建立的模型去解决实际中遇到的问题，它还包括了监督、维持、产生最终报表、重新评估模型等过程。</li>
</ul>
<p>数据挖掘入门的书籍，中文的大体有这些：<br>Jiawei Han的《数据挖掘概念与技术》<br>Ian H. Witten &#x2F; Eibe Frank的《数据挖掘 实用机器学习技术》<br>Tom Mitchell的《机器学习》<br>TOBY SEGARAN的《集体智慧编程》<br>Anand Rajaraman的《大数据》<br>Pang-Ning Tan的《数据挖掘导论》<br>Matthew A. Russell的《社交网站的数据挖掘与分析》</p>
<p>自我介绍；<br>挑一个重点项目详细讲一下；<br>为什么选树模型做这个项目，优势在哪里（重点就是可以实现并行化，而且效果也不错，原理也没有很复杂）；<br>Xgboost 的 loss 函数有什么特点，与其他树模型有什么区别（可以控制模型复杂度）；<br>Xgboost 调参怎么做，重要的参数有哪些；<br>Python 用过哪些包；<br>Python 元组和列表的区别；<br>Python 深复制和浅复制；<br>Numpy 中矩阵乘法有几种（一定要分清元素乘法和矩阵乘法）；<br>Pandas 读取文件如何操作；<br>SQL 索引底层算法用什么实现的，算法原理是什么（ b+ 树）；<br>b 树 和 b+ 树 的区别（ b+ 树只在叶节点存储数据，而且叶节点之间有双向链表连接，这样可以做到范围查询，而b树或者 b- 树做不到这一点）；<br>SQL 如何优化（小表驱动大表，避免查询回表，尽量使用索引提高查询效率，尽量索引覆盖，少用 in、group by 这些等等）；<br>连接有几种，有什么区别（left join， right join 等等，区别就是谁是主表的问题）；<br>开窗函数了解吗，讲一下吧；<br>出了一个 SQL 题，比较简单，就是分组排序那些，leetcode 上面有原题；<br>样本均衡算法的细节（内部使用了 knn 算法）；<br>方差和偏差的概念（两者之间要选取均衡，不能只关注低偏差，容易造成过拟合问题）；<br>常用的评价指标，Precision，Recall，MAE等等；<br>对大数据是否接触过；</p>
]]></content>
      <categories>
        <category>Data Science</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title>English Writing</title>
    <url>/2022/09/21/English-Writing/</url>
    <content><![CDATA[<h3 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title=" Vocabulary"></a><font color="6FBCE1"> Vocabulary</font></h3><p>appropriate, essential, tremendous, considerable, significantly, massive, generous, huge, large<br>anxiety, necessarily, certainly, constantly, heavily, nearly, unfortunately<br>secure, severe, economic, intensive, particular<br>comfortable, glad, pleased, pleasant<br>devote, disturb, a phenomenon, tough<br>famous, well-known</p>
<h3 id="Phrase"><a href="#Phrase" class="headerlink" title=" Phrase"></a><font color="977FD7"> Phrase</font></h3><p>run out of energy, keep air conditioners on<br>all the time, raise children, birth rate, acquire knowledge, achieve goals<br>play sports, score points<br>on my own, mental and physical health<br>a huge fee, relieve poverty</p>
<h3 id="Organization"><a href="#Organization" class="headerlink" title=" Organization"></a><font color="008000"> Organization</font></h3><h3 id="Errors"><a href="#Errors" class="headerlink" title=" Errors"></a><font color="FC572B"> Errors</font></h3><p>单复数s, 冠词a&#x2F;the,<br>running, cutting, eating<br>destroyed, limited, committed, submitted<br>hundred, thousand, </p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>She suffers from a lack of confidence.<br>He’s ignorant about modern&#x2F;space technology.<br>Medical technology has advanced considerably.<br>Competition for jobs is acute. &#x2F;intense<br>The strategy worked brilliantly.<br>She’s responsible for the hirings and firings.<br>He decided to devote the rest of his life to scientific investigation.<br>The need for sleep varies considerably from person to person.<br>Most of my salary goes on the rent.<br>Because there’s a power outage.<br>It is worth the effort.<br>Rent is a huge expense&#x2F;cost for students.<br>We hope to prevent anything unpleasant from happening.<br>With the advancement of science and technology, people’s living standards have improved significantly.<br>She loves all sports, especially swimming.<br>Bill Gates regularly donates money to charity.<br>A good diet is beneficial to health.</p>
<h3 id="Bill-Gates"><a href="#Bill-Gates" class="headerlink" title="Bill Gates"></a>Bill Gates</h3><p>“We all need people who will give us feedback. That’s how we improve.”<br>Bill Gates frequently talks about the need for constant self-improvement. It’s important to have people in our lives who will give us honest, constructive feedback. This is the only way we can grow and become better.</p>
<p>Bill Gates<br>What impresses me most is his saying, “Patience is a key element of success.” Success usually comes after a lot of trials and errors and a lot of failures. Successful individuals are those who have the patience to stick through all the frustrating moments along the way. Probably I cannot be a Bill Gates myself, but I can be a hard-working learner. From him, I realize the secret to success is not when or where you were born but what you do and how you do it in your life.</p>
<p><a href="https://writing.wisc.edu/handbook/style/transitions/">transitional words phrases</a><br>Transitions to help establish some of the most common kinds of relationships</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/08/14/Linux/</url>
    <content><![CDATA[<p>Linux八股（持续更新中）</p>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用变量的时，用英文符号”$”取变量值，对于较长的变量名，建议加上{ }花括号，帮助解释器识别变量的边界</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;test_name&quot;</span><br><span class="line">echo &quot;My name is $&#123;name&#125;and you&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning</title>
    <url>/2022/08/12/Machine-Learning/</url>
    <content><![CDATA[<p>Machine learning is the field of study that gives computers the ability to learn without being explicitly programmed.</p>
<h3 id="1-特征工程"><a href="#1-特征工程" class="headerlink" title="1. 特征工程"></a>1. 特征工程</h3><p>两种归一化<br>类别型的三种特征<br>高维组合特征处理<br>如何进行特征的组合</p>
<h4 id="1-1-标准化-归一化"><a href="#1-1-标准化-归一化" class="headerlink" title="1.1 标准化,归一化"></a>1.1 标准化,归一化</h4><blockquote>
<p>在进行距离有关的计算时，单位的不同会导致计算结果的不同，尺度大的特征会起决定性作用，而尺度小的特征其作用可能会被忽略。为了消除特征间单位和尺度差异的影响，以对每维特征同等看待，需要对特征进行归一化。</p>
</blockquote>
<span id="more"></span>
<ul>
<li>提升模型精度</li>
<li>提升收敛速度</li>
<li>解决数值计算的一些问题</li>
</ul>
<h4 id="1-2-什么是组合特征？如何处理高维组合特征？"><a href="#1-2-什么是组合特征？如何处理高维组合特征？" class="headerlink" title="1.2 什么是组合特征？如何处理高维组合特征？"></a>1.2 什么是组合特征？如何处理高维组合特征？</h4><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组 合，构成高阶组合特征。可以采取降维，矩阵分解或者特征筛选的方法得到具备绝大部分信息的几个特征进行训练。</p>
<h4 id="1-3-欧氏距离-Euclidean-Distance-和曼哈顿距离"><a href="#1-3-欧氏距离-Euclidean-Distance-和曼哈顿距离" class="headerlink" title="1.3 欧氏距离(Euclidean Distance)和曼哈顿距离"></a>1.3 欧氏距离(Euclidean Distance)和曼哈顿距离</h4><ul>
<li>欧氏距离：欧几里得距离，就是平方和开根号。我们最常用的。欧氏距离越小，两个向量的相似度越大；欧氏距离越大，两个向量的相似度越小。</li>
<li>曼哈顿距离：|x1 - x2| + |y1 - y2|，曼哈顿距离也称为城市街区距离。可以看出在曼哈顿距离中，考虑了更多的实际因素。总之在曼哈顿距离的世界中，规则是我们只能沿着线画出的格子行进。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enclidean_distance</span>(<span class="params">row1,row1</span>): <span class="comment">#one row represents a point</span></span><br><span class="line">	distance=<span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(row1)-<span class="number">1</span>):</span><br><span class="line">		distance+=(row1[i]-row2[i])**<span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> sqrt(distance)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-4-什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？"><a href="#1-4-什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？" class="headerlink" title="1.4 什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？"></a>1.4 什么是余弦相似度？为什么有些场景使用余弦相似度而不使用欧氏距离？</h4><p>对于两个向量A和B，其余弦相似度定义为cos（A，B）＝ A<em>B &#x2F; |A|</em>|B| 即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小,余弦相似度依然符合“相同为1，正交为0，相反为-1”的性质，其取值范围是［-1，1］。欧式距离衡量空间点的直线距离，余弦距离衡量点在空间的方向差异。欧式距离体现的数值上的绝对差异，而余弦距离体现方向上的相对差异。</p>
<h4 id="1-5-one-hot的作用是什么？为什么不能直接用数字来表示？"><a href="#1-5-one-hot的作用是什么？为什么不能直接用数字来表示？" class="headerlink" title="1.5 one-hot的作用是什么？为什么不能直接用数字来表示？"></a>1.5 one-hot的作用是什么？为什么不能直接用数字来表示？</h4><p>One-Hot编码是分类变量作为二进制向量的表示。这首先要求将分类值映射到整数值。然后，每个整数值被表示为二进制向量，除了整数的索引之外，它都是零值，它被标记为1。<a href="https://cloud.tencent.com/developer/article/1688022">One-Hot详解</a>，直接使用数字会给将人工误差而导致的假设引入到类别特征中，比如类别之间的大小关系，以及差异关系等等</p>
<h3 id="2-模型评估"><a href="#2-模型评估" class="headerlink" title="2. 模型评估"></a>2. 模型评估</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><ul>
<li>准确率，召回率<table>
<thead>
<tr>
<th align="center">Evalutation</th>
<th align="center">predicted Postive</th>
<th align="center">predicted Negative</th>
</tr>
</thead>
<tbody><tr>
<td align="center">real Postive</td>
<td align="center">TP</td>
<td align="center">FN</td>
</tr>
<tr>
<td align="center">real Negative</td>
<td align="center">FP</td>
<td align="center">TN</td>
</tr>
</tbody></table>
</li>
</ul>
<p>Precision &#x3D; TP&#x2F;TP+FP 预测为正例的样本中有多少真正的正例<br>Recall &#x3D; TP&#x2F;TP+FN 所有的正例中有多少被预测出来</p>
<ul>
<li><p>ROC曲线（Receiver Operating Characteristic）PR曲线，<br>ROC是一个用于度量分类中的非均衡性的工具，ROC曲线及AUC常被用来评价一个二值分类器的优劣。</p>
</li>
<li><p>AUC（Area Under Curve）<br>AUC 被定义为ROC曲线下的面积，因为ROC曲线一般都处于y&#x3D;x这条直线的上方，所以取值范围在0.5和1之间，使用AUC作为评价指标是因为ROC曲线在很多时候并不能清晰地说明哪个分类器的效果更好，而AUC作为一个数值，其值越大代表分类器效果更好。</p>
</li>
</ul>
<p>The AUC value is equivalent to the probability that a randomly chosen positive example is ranked higher than a randomly chosen negative example.</p>
<p>首先AUC是一个概率值，当随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的分数将这个正样本排在负样本前面的概率就是AUC值。所以，AUC的值越大，当前的分类算法越有可能将正样本排在负样本值前面，既能够更好的分类。</p>
<ul>
<li>超参数调优</li>
<li>欠拟合，过拟合<br>训练集上表现很好，测试集上表现很差。欠拟合：训练集上表现很差。欠拟合会导致高 Bias ，过拟合会导致高 Variance ，所以模型需要在 Bias与Variance之间做出一个权衡。<br><em>Bias</em> 和 <em>Variance</em> 分别从两个方面来描述我们学习到的模型与真实模型之间的差距。<br>Bias 是用所有可能的训练数据集训练出的所有模型的输出的平均值与真实模型的输出值之间的差异。<br>Variance 是不同的训练数据集训练出的模型输出值之间的差异。</li>
</ul>
<blockquote>
<p>Error &#x3D; Bias + Variance + Noise，Error反映的是整个模型的准确度，Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度，Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。</p>
</blockquote>
<h4 id="2-2-降低过拟合和欠拟合的方法"><a href="#2-2-降低过拟合和欠拟合的方法" class="headerlink" title="2.2 降低过拟合和欠拟合的方法"></a>2.2 降低过拟合和欠拟合的方法</h4><p>(1)解决欠拟合的方法：</p>
<ol>
<li>增加新特征，可以考虑加入进特征组合、高次特征，来增大假设空间;</li>
<li>尝试非线性模型，比如核SVM 、决策树、DNN等模型;</li>
<li>如果有正则项可以较小正则项参数 $\lambda$;</li>
<li>Boosting ,Boosting 往往会有较小的 Bias，比如 Gradient Boosting 等.</li>
</ol>
<p>(2)解决过拟合的方法：</p>
<ol>
<li>交叉验证，通过交叉检验得到较优的模型参数;</li>
<li>减少特征的数量（-人工选择保留哪些特征，-模型选择算法）,ditch some non-linear attributes</li>
<li>正则化, make lambda bigger</li>
<li>collect more training data</li>
</ol>
<h4 id="K-fold-Cross-Validation"><a href="#K-fold-Cross-Validation" class="headerlink" title="K-fold Cross Validation"></a>K-fold Cross Validation</h4><p>• Assessing how the results of a statistical analysis will generalize to an independent data set<br>• Finding an optimal set of parameters without seeing the testing samples</p>
<blockquote>
<p>正则化</p>
</blockquote>
<h4 id="2-4-对于树形结构为什么不用归一化？"><a href="#2-4-对于树形结构为什么不用归一化？" class="headerlink" title="2.4 对于树形结构为什么不用归一化？"></a>2.4 对于树形结构为什么不用归一化？</h4><p>因为数值缩放不影响分裂点位置，对树模型的结构不造成影响。按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。而且，树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。树型结构不关心变量的值，只关心变量分布以及变量之间的条件概率</p>
<h4 id="2-5-什么是数据不平衡？如何解决？"><a href="#2-5-什么是数据不平衡？如何解决？" class="headerlink" title="2.5 什么是数据不平衡？如何解决？"></a>2.5 什么是数据不平衡？如何解决？</h4><p>在机器学习中我们经常会遇到数据不平衡问题。数据不平衡主要存在于有监督机器学习任务中。当遇到数据不平衡时，以总体分类准确率为学习目标的传统分类算法会过多地关注多数类，从而使得少数样本的分类性能下降。绝大多数常见的机器学习算法对于不平衡数据集都不能很好地工作。</p>
<h3 id="3-线性回归，逻辑回归"><a href="#3-线性回归，逻辑回归" class="headerlink" title="3. 线性回归，逻辑回归"></a>3. 线性回归，逻辑回归</h3><h3 id="SVM-Support-Vector-Machines"><a href="#SVM-Support-Vector-Machines" class="headerlink" title="SVM(Support Vector Machines)"></a>SVM(Support Vector Machines)</h3><p>Maximize the Margin<br>Hyperplane</p>
<ul>
<li>Polynomial Kernel</li>
<li>Gaussian Kernel</li>
</ul>
<h3 id="4-朴素贝叶斯"><a href="#4-朴素贝叶斯" class="headerlink" title="4. 朴素贝叶斯"></a>4. 朴素贝叶斯</h3><ul>
<li>Generative model<br>• Based on generation assumptions, which category is most likely to generate this observation</li>
<li>Discriminative model<br>• Not care about how the data was generated, simply categorizes a given observation</li>
</ul>
<h3 id="5-决策树"><a href="#5-决策树" class="headerlink" title="5. 决策树"></a>5. 决策树</h3><h3 id="6-降维"><a href="#6-降维" class="headerlink" title="6. 降维"></a>6. 降维</h3><ul>
<li>PCA</li>
<li>LDA</li>
</ul>
<h3 id="7-优化算法"><a href="#7-优化算法" class="headerlink" title="7. 优化算法"></a>7. 优化算法</h3><p>有监督的损失函数<br>梯度验证<br>L1、L2正则<br>L1范数，其表示某个向量中所有元素绝对值的和。<br>L2范数，表示某个向量中所有元素平方和再开根，也就是欧氏距离</p>
<h3 id="8-集成学习-bagging-boosting"><a href="#8-集成学习-bagging-boosting" class="headerlink" title="8. 集成学习(bagging, boosting)"></a>8. 集成学习(bagging, boosting)</h3><p>所谓的集成学习，就是用多重或多个弱分类器结合为一个强分类器，从而达到提升分类方法效果。严格来说，集成学习并不算是一种分类器，而是一种分类器结合的方法。</p>
<p><strong>Bagging和Boosting的主要区别</strong></p>
<blockquote>
<p>Bagging采取Bootstraping的是随机有放回的取样，Boosting的每一轮训练的样本是固定的，改变的是每个样本的权重。<br>Bagging采取的是均匀取样，每个样本的权重相同，Boosting根据错误率调整样本权重，错误率越大的样本权重越大<br>Bagging所有预测函数权值相同，Boosting中误差越小的预测函数权值越大。<br>Bagging 的各个预测函数可以并行生成;Boosting的各个预测函数必须按照顺序迭代生成</p>
</blockquote>
<h5 id="Bagging和Boosting的区别："><a href="#Bagging和Boosting的区别：" class="headerlink" title="Bagging和Boosting的区别："></a>Bagging和Boosting的区别：</h5><ol>
<li><p>样本选择上：<br>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。<br>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p>
</li>
<li><p>样例权重：<br>Bagging：使用均匀取样，每个样例的权重相等<br>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p>
</li>
<li><p>预测函数：<br>Bagging：所有预测函数的权重相等。<br>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p>
</li>
<li><p>并行计算：<br>Bagging：各个预测函数可以并行生成<br>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>
</li>
</ol>
<p>将Bagging和Boosting分别和树模型结合分别生成：</p>
<p>Bagging+决策树&#x3D;随机森林<br>Boosting+决策树&#x3D;GBDT</p>
<blockquote>
<p><strong>那么，为什么集成学习会好于单个学习器呢？原因可能有三：</strong><br>训练样本可能无法选择出最好的单个学习器，由于没法选择出最好的学习器，所以干脆结合起来一起用；<br>假设能找到最好的学习器，但由于算法运算的限制无法找到最优解，只能找到次优解，采用集成学习可以弥补算法的不足；<br>可能算法无法得到最优解，而集成学习能够得到近似解。比如说最优解是一条对角线，而单个决策树得到的结果只能是平行于坐标轴的，但是集成学习可以去拟合这条对角线。</p>
</blockquote>
<p><strong>Rand forest：</strong> 随机森林，顾名思义，是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。 在建立每一棵决策树的过程中，有两点需要注意 - 采样与完全分裂。首先是两个随机采样的过程，random forest对输入的数据要进行行、列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting。然后进行列采样，从M个feature中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。一般很多的决策树算法都一个重要的步骤-剪枝，但是这里不这样干，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。 按这种算法得到的随机森林中的每一棵都是很弱的，但是大家组合起来就很厉害了。可以这样比喻随机森林算法：每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从M个feature中选择m让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。</p>
<p>Independence in probability<br>If the probability of occurrence of one event does not affect the probability of occurrence of the other event, these two events are called indenpendent.</p>
<p>XGBoost</p>
<blockquote>
<p>聚类:KNN, SVM, Boosting, 推荐系统，正则化，异常检测，EM算法，</p>
</blockquote>
<ul>
<li><input disabled type="checkbox"> 1）L1 L2正则化的区别，为什么正则化（字节）</li>
<li><input disabled type="checkbox"> 2）如何解决多重共线性–其实也是正则问题（快手）</li>
<li><input disabled type="checkbox"> 3）召回率，准确率分别是什么（B站）</li>
<li><input disabled type="checkbox"> 4）bagging 和boosting 的区别（B站）</li>
<li><input disabled type="checkbox"> 5）聚类算法的好坏，流程（百度）</li>
<li><input disabled type="checkbox"> 6）决策树ID3 的启发函数（猿辅导）</li>
<li><input disabled type="checkbox"> 7）PCA（拼多多）</li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2022/09/04/Java/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title=" 基础知识 "></a><center> <font color="FC572B">基础知识</font> </center></h2><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li>简单易学</li>
<li>面向对象(封装、继承、多态)</li>
<li>平台无关性(Java虚拟机实现平台无关性)由于 Java 为解释型语言，编译器会把 Java 代码变成 “中间代码”， 然后在 Java 虚拟机（ Java Virtual Machine，JVM）上解释执行。 由于中间代码与平台无关，因此，Java 语言可以很好地<br>跨平台执行，具有很好的可移植性。</li>
<li>支持多线程 (C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持)</li>
<li>具有较好的安全性和健壮性。Java语言经常被用在网络环境中，为了增强程序的安全性，Java语言提供了一个防止恶意代码攻击的安全机制 （数组边界检测和 Bytecode 校验等）。Java 的强类型机制、 垃圾回收器、 异常处理和安全检查机制使得用 Java 语言编写的程序有很好的健壮性。（相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。）</li>
<li>支持Web应用开发，例如，Applet、Servlet和JSP可以用来开发Web应用程序；Socket、RMI可以用来开发分布式应用程序的类库。</li>
<li>去除了C＋＋语言中难以理解、容易混淆的特性，例如头文件、指针、结构、单元、运算符重载、虚拟基础类、多重继承等，使得程序更加严谨、 简洁。</li>
</ol>
<h4 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM - JDK - JRE"></a>JVM - JDK - JRE</h4><p>Java 虚拟机（Java virtual machine, JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS),目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言”一次编译，随处运行”的关键所在。（提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心）</p>
<p>JDK(Java Development Kit)开发工具包,它是功能齐全的JavaSDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序.</p>
<p>JRE（Java Runtime Environment）运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<h4 id="Java-如何实现平台无关？"><a href="#Java-如何实现平台无关？" class="headerlink" title="Java 如何实现平台无关？"></a>Java 如何实现平台无关？</h4><p>JVM： Java 编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。</p>
<p>语言规范： 基本数据类型大小有明确规定，例如 int 永远为 32 位，而 C&#x2F;C++中可能是16位、32位，也可能是编译器开发商指定的其他大小。Java中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的 Unicode 格式存储。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p>
<h4 id="浅拷贝-vs-深拷贝"><a href="#浅拷贝-vs-深拷贝" class="headerlink" title="浅拷贝 vs 深拷贝"></a>浅拷贝 vs 深拷贝</h4><p>浅拷贝：只复制当前对象的基本数据类型及引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。<br>深拷贝：完全拷贝基本数据类型和引用数据类型，安全。</p>
<h4 id="JDK8-新特性"><a href="#JDK8-新特性" class="headerlink" title="JDK8 新特性"></a>JDK8 新特性</h4><p><strong>lambda 表达式：</strong> 允许把函数作为参数传递到方法，简化匿名内部类代码。<br><strong>函数式接口：</strong> 使用 @FunctionalInterface 标识，有且仅有一个抽象方法，可被隐式转换为 lambda 表达式。<br><strong>方法引用：</strong> 可以引用已有类或对象的方法和构造方法，进一步简化 lambda 表达式。<br><strong>接口：</strong> 接口可以定义 default 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。<br><strong>注解:</strong> 引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。<br><strong>类型推测：</strong> 加强了类型推测机制，使代码更加简洁。<br><strong>Optional 类：</strong> 处理空指针异常，提高代码可读性。<br><strong>Stream 类：</strong> 引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括forEach遍历、count统计个数、filter 按条件过滤、limit 取前 n 个元素、skip 跳过前 n 个元素、map 映射加工、concat 合并 stream 流等。<br><strong>日期：</strong> 增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期&#x2F;时间、时区、时刻和时钟等操作。<br><strong>JavaScript：</strong> 提供了一个新的 JavaScript 引擎，允许在 JVM上运行特定 JavaScript 应用。</p>
<h4 id="异常有哪些分类"><a href="#异常有哪些分类" class="headerlink" title="异常有哪些分类"></a>异常有哪些分类</h4><p>所有异常都是 Throwable 的子类，分为 Error 和 Exception. Error是Java运行时系统的内部错误和资源耗尽错误，例如 StackOverFlowError 和 OutOfMemoryError，这种异常程序无法处理。</p>
<p><strong>Exception</strong> 分为受检异常和非受检异常，受检异常需要在代码中显式处理，否则会编译出错，非受检异常是运行时异常，继承自RuntimeException<br><strong>受检异常：</strong> ① 无能为力型，如字段超长导致的SQLException。②力所能及型，如未授权异常UnAuthorizedException，程序可跳转权限申请页面。常见受检异常还有 FileNotFoundException、ClassNotFoundException、IOException等。<br><strong>非受检异常：</strong> ① 可预测异常，例如IndexOutOfBoundsException、NullPointerException、ClassCastException等，这类异常应该提前处理。② 需捕捉异常，例如进行RPC调用时的远程服务超时，这类异常客户端必须显式处理。③可透出异常，指框架或系统产生的且会自行处理的异常，例如Spring的NoSuchRequestHandingMethodException，Spring会自动完成异常处理，将异常自动映射到合适的状态码。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>8 种基本数据类型：</p>
<ul>
<li>6 种数字类型：<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">位数</th>
<th align="left">字节</th>
<th align="left">默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left">1</td>
<td align="left"></td>
<td align="left">false</td>
<td>true、false</td>
</tr>
</tbody></table>
<h4 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h4><table>
<thead>
<tr>
<th align="left">分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">类，方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td align="left"></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td align="left">程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td align="left"></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td align="left">错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td align="left"></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。<br><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。<br>⚠️ 注意 ：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</li>
</ul>
</blockquote>
<h4 id="continue-break-return"><a href="#continue-break-return" class="headerlink" title="continue - break - return"></a>continue - break - return</h4><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>
<ol>
<li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li>
</ol>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>
<ol>
<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>
</ol>
<hr>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="对面向对象的理解"><a href="#对面向对象的理解" class="headerlink" title="对面向对象的理解"></a>对面向对象的理解</h4><p>面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型项目，软件复用和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。</p>
<p>例如开门这个动作，面向过程是 open(Door door)，动宾结构，door作为操作对象的参数传入方法，方法内定义开门的具体步骤。面向对象的方式首先会定义一个类Door，抽象出门的属性（如尺寸、颜色）和行为（如 open 和 close），主谓结构。</p>
<p>面向过程代码松散，强调流程化解决问题。面向对象代码强调高内聚、低耦合，先抽象模型定义共性行为，再解决实际问题。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<blockquote>
<p><strong>如果一个类没有声明构造方法，该程序能正确执行吗?</strong><br>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
</blockquote>
<p>构造方法特点：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以可以看到一个类中有多个构造函数的情况。</p>
<h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p><strong>封装</strong> 是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。<br>迪米特原则就是对封装的要求，即A模块使用B模块的某接口行为，对B模块中除此行为外的其他信息知道得应尽可能少。不直接对public属性进行读取和修改而使用getter&#x2F;setter方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将public的属性和行为修改为private一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private<br><strong>继承</strong> 用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。<br><strong>多态</strong> 以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。多态指在编译层面无法确定最终调用的方法体，在运行期由JVM动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h4 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<h4 id="重载-vs-重写"><a href="#重载-vs-重写" class="headerlink" title="重载 vs 重写"></a>重载 vs 重写</h4><p><strong>重载</strong> 指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。对编译器来说，方法名称和参数列表组成了一个唯一键，称为方法签名，JVM 通过方法签名决定调用哪种重载方法。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法，因此属于静态绑定。</p>
<p><strong>重写</strong> 指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。<br>元空间有一个方法表保存方法信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实现。父类引用执行子类方法时无法调用子类存在而父类不存在的方法。<br>重写方法访问权限不能变小，返回类型和抛出的异常类型不能变大，必须加 @Override</p>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发生范围</td>
<td align="left">同一个类</td>
<td align="left">子类</td>
</tr>
<tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可修改</td>
<td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可修改</td>
<td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">可修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="left">发生阶段</td>
<td align="left">编译期</td>
<td align="left">运行期</td>
</tr>
</tbody></table>
<h4 id="访问权限控制符"><a href="#访问权限控制符" class="headerlink" title="访问权限控制符"></a>访问权限控制符</h4><table>
<thead>
<tr>
<th align="center">控制符</th>
<th align="center">本类</th>
<th align="center">包内</th>
<th align="center">包外子类</th>
<th align="center">任何地方</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">无</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h4 id="子类初始化顺序"><a href="#子类初始化顺序" class="headerlink" title="子类初始化顺序"></a>子类初始化顺序</h4><p>①父类静态代码块和静态变量。<br>②子类静态代码块和静态变量。<br>③父类普通代码块和普通变量。<br>④父类构造方法。<br>⑤子类普通代码块和普通变量。<br>⑥子类构造方法。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><hr>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><hr>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><hr>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><hr>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="Java-程序怎样运行"><a href="#Java-程序怎样运行" class="headerlink" title="Java 程序怎样运行"></a>Java 程序怎样运行</h4><h2 id="●-首先通过-Javac-编译器将-java-转为-JVM-可加载的-class-字节码文件。Javac-是由-Java-编写的程序，编译过程可以分为：-①-词法解析，通过空格分割出单词、操作符、控制符等信息，形成-token-信息流，传递给语法解析器。②-语法解析，把-token-信息流按照-Java-语法规则组装成语法树。③-语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④-字节码生成，将前面各个步骤的信息转换为字节码。字节码必须通过类加载过程加载到-JVM-后才可以执行，执行有三种模式，解释执行、JIT-编译执行、JIT-编译与解释器混合执行（主流-JVM-默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。●-之后通过即时编译器-JIT-把字节码文件编译成本地机器码。Java-程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。●-还可以通过静态的提前编译器-AOT-直接把程序编译成与目标机器指令集相关的二进制代码。-类加载Class-文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的-Java-类型，这个过程称为虚拟机的类加载机制。与编译时需要连接的语言不同，Java中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java-动态扩展的语言特性就是依赖运行期动态加载和连接实现的。一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持-Java-的动态绑定。"><a href="#●-首先通过-Javac-编译器将-java-转为-JVM-可加载的-class-字节码文件。Javac-是由-Java-编写的程序，编译过程可以分为：-①-词法解析，通过空格分割出单词、操作符、控制符等信息，形成-token-信息流，传递给语法解析器。②-语法解析，把-token-信息流按照-Java-语法规则组装成语法树。③-语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④-字节码生成，将前面各个步骤的信息转换为字节码。字节码必须通过类加载过程加载到-JVM-后才可以执行，执行有三种模式，解释执行、JIT-编译执行、JIT-编译与解释器混合执行（主流-JVM-默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。●-之后通过即时编译器-JIT-把字节码文件编译成本地机器码。Java-程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。●-还可以通过静态的提前编译器-AOT-直接把程序编译成与目标机器指令集相关的二进制代码。-类加载Class-文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的-Java-类型，这个过程称为虚拟机的类加载机制。与编译时需要连接的语言不同，Java中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java-动态扩展的语言特性就是依赖运行期动态加载和连接实现的。一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持-Java-的动态绑定。" class="headerlink" title="● 首先通过 Javac 编译器将 .java 转为 JVM 可加载的 .class 字节码文件。Javac 是由 Java 编写的程序，编译过程可以分为： ① 词法解析，通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器。② 语法解析，把 token 信息流按照 Java 语法规则组装成语法树。③ 语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④ 字节码生成，将前面各个步骤的信息转换为字节码。字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。● 之后通过即时编译器 JIT 把字节码文件编译成本地机器码。Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。● 还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。#### 类加载Class 文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程称为虚拟机的类加载机制。与编译时需要连接的语言不同，Java中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java 动态扩展的语言特性就是依赖运行期动态加载和连接实现的。一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持 Java 的动态绑定。"></a>● 首先通过 Javac 编译器将 .java 转为 JVM 可加载的 .class 字节码文件。<br>Javac 是由 Java 编写的程序，编译过程可以分为： ① 词法解析，通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器。② 语法解析，把 token 信息流按照 Java 语法规则组装成语法树。③ 语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④ 字节码生成，将前面各个步骤的信息转换为字节码。<br>字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。<br>● 之后通过即时编译器 JIT 把字节码文件编译成本地机器码。<br>Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。<br>● 还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。<br>#### 类加载<br>Class 文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程称为虚拟机的类加载机制。<br>与编译时需要连接的语言不同，Java中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java 动态扩展的语言特性就是依赖运行期动态加载和连接实现的。<br>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持 Java 的动态绑定。</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h3 id="Java-Programming"><a href="#Java-Programming" class="headerlink" title="Java Programming"></a>Java Programming</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(set);<span class="comment">// 输出结果：[李四, 张三]</span></span><br><span class="line"><span class="comment">// 张三被添加了两次，它在集合中也只会出现一次，因为集合中的每个元素都必须是唯一的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line">System.out.println(set.contains(<span class="string">&quot;李四&quot;</span>));<span class="comment">// 输出结果：true</span></span><br><span class="line">System.out.println(set.contains(<span class="string">&quot;王二&quot;</span>));<span class="comment">// 输出结果：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素,删除成功返回true，否则返回false</span></span><br><span class="line">System.out.println(set.remove(<span class="string">&quot;张三&quot;</span>));<span class="comment">// 输出结果：true</span></span><br><span class="line"></span><br><span class="line">System.out.println(set.size());<span class="comment">// 输出结果：3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Programming</title>
    <url>/2022/09/23/Python-Programming/</url>
    <content><![CDATA[<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="列表的11种方法"><a href="#列表的11种方法" class="headerlink" title="列表的11种方法"></a>列表的11种方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. append 将一个对象附加到列表末尾</span></span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list1.append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. clear 清空列表的内容</span></span><br><span class="line">list1.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. copy 复制列表 (常规复制只是将另一个名称关联到列表)</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b=a</span><br><span class="line">b[<span class="number">1</span>]=<span class="number">4</span></span><br><span class="line"><span class="comment"># a: [1,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4. count 计算指定的元素在列表中出现了多少次</span></span><br><span class="line">list1.count(<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5. extend 同时将多个值附加到列表末尾</span></span><br><span class="line">list1.extend(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#6. index 查找指定值第一次出现的索引</span></span><br><span class="line">list1.index(<span class="number">2</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7. insert 将一个对象插入列表</span></span><br><span class="line">list1.insert(<span class="number">1</span>,<span class="string">&quot;four&quot;</span>) <span class="comment"># [1,&quot;four&quot;,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8. pop 从列表中删除一个元素（默认为最后一个元素），并返回这一元素</span></span><br><span class="line">list1.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">#9. remove 删除.第一个.为指定值的元素</span></span><br><span class="line">list1.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">#10. reverse 按相反的顺序排列列表中的元素</span></span><br><span class="line">list1.reverse() <span class="comment"># [3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#11. sort 对列表就地排序</span></span><br><span class="line">list1.sort()</span><br><span class="line">x = [<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;abalone&#x27;</span>, <span class="string">&#x27;acme&#x27;</span>, <span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;aerate&#x27;</span>]</span><br><span class="line">x.sort(key=<span class="built_in">len</span>) <span class="comment"># [&#x27;add&#x27;, &#x27;acme&#x27;, &#x27;aerate&#x27;, &#x27;abalone&#x27;, &#x27;aardvark&#x27;]</span></span><br><span class="line">x = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">x.sort(reverse=<span class="literal">True</span>) <span class="comment"># [9, 7, 6, 4, 2, 1]</span></span><br><span class="line">x.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># list生成加判断语句</span></span><br><span class="line">label_list = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> label_list <span class="keyword">if</span> i&gt;<span class="number">3</span>]</span><br><span class="line"><span class="comment"># list连成字符串</span></span><br><span class="line">s=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;t&quot;</span>]</span><br><span class="line">t=<span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line"><span class="string">&quot;123t&quot;</span></span><br><span class="line"><span class="comment"># 列表相加组成新列表</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(a)&lt;<span class="number">5</span>:</span><br><span class="line">  a+=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><strong>反转list</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内建函数reversed()</span></span><br><span class="line">s=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x=<span class="built_in">list</span>(<span class="built_in">reversed</span>(s))</span><br><span class="line"><span class="comment">#使用切片</span></span><br><span class="line">d=s[::-<span class="number">1</span>]  <span class="comment">#[::-1]代表从后向前取值，每次步进值为1</span></span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="built_in">sorted</span>(a,reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">sorted</span>(a,key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>],-x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#list反转（也适用于字符串）</span></span><br><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">newList = <span class="built_in">list</span>(<span class="built_in">reversed</span>(list2))。 </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;reversed()函数返回的是一个迭代器，而不是一个List，所以需要list函数转换一下&quot;</span>,newList)</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建空字典</span></span><br><span class="line">dic = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>,<span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;b&quot;</span>:<span class="number">2</span>,<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">a[<span class="string">&#x27;a&#x27;</span>] <span class="number">1</span></span><br><span class="line">a == b <span class="literal">True</span></span><br><span class="line"><span class="comment"># 字典排序</span></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">34</span>&#125;</span><br><span class="line"><span class="comment"># 按照字典的值进行排序</span></span><br><span class="line">a1 = <span class="built_in">sorted</span>(a.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment"># -x[1]降序</span></span><br><span class="line">[(<span class="string">&#x27;b&#x27;</span>, <span class="number">0</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">34</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">89</span>)] <span class="comment"># 输出结果是list，每个元素是tuple</span></span><br><span class="line"><span class="comment"># 按照字典的键进行排序</span></span><br><span class="line">a2 = <span class="built_in">sorted</span>(a.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 转化成数值类型，对绝对值排序，最终结果转化成字典</span></span><br><span class="line">count = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(count.items, key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(<span class="built_in">float</span>(x[<span class="number">0</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按值排序后结果&#x27;</span>, a1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按键排序后结果&#x27;</span>, a2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果转为字典格式&#x27;</span>, <span class="built_in">dict</span>(a1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果转为字典格式&#x27;</span>, <span class="built_in">dict</span>(a2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历字典</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="built_in">print</span>(key,value)</span><br></pre></td></tr></table></figure>
<h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">s=<span class="string">&quot;abacd&quot;</span></span><br><span class="line">count = collections.Counter(s)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> count.values():</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"><span class="comment"># 统计各个元素数量</span></span><br><span class="line">count = Counter(ntc)</span><br><span class="line">count = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(count.items(), key=<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x[<span class="number">0</span>][<span class="number">1</span>:]))) <span class="comment"># T1,T10排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">edges = defaultdict(<span class="built_in">list</span>) <span class="comment"># 默认初始化空list</span></span><br><span class="line">edges[<span class="string">&#x27;a&#x27;</span>].append(<span class="number">2</span>)</span><br><span class="line">t=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">need=defaultdict(<span class="built_in">int</span>) <span class="comment"># 默认初始化0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">    need[i]+=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="print用法总结"><a href="#print用法总结" class="headerlink" title="print用法总结"></a>print用法总结</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    <span class="comment">#无空格，无换行</span></span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>) <span class="comment">#换行</span></span><br><span class="line">a=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>+<span class="built_in">str</span>(a)) <span class="comment">#无空格+数字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;www&quot;</span>, <span class="string">&quot;taihangli&quot;</span>, <span class="string">&quot;net&quot;</span>, sep=<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;1&#125;+&#123;0&#125;=&#123;2&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="number">1</span>+<span class="number">0</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="input-用法总结"><a href="#input-用法总结" class="headerlink" title="input()用法总结"></a>input()用法总结</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=<span class="built_in">input</span>().split()</span><br><span class="line"><span class="comment"># 规律的字符串切分成列表</span></span><br><span class="line">volts = df.loc[<span class="number">0</span>,<span class="string">&#x27;volts&#x27;</span>].split(<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">volts = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> volts]</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="string">&#x27;, &#x27;</span>.join(volts)</span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">global</span> a   <span class="comment"># 声明引用的是全局变量</span></span><br><span class="line">    <span class="keyword">nonlocal</span> a <span class="comment"># balabala</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>
<h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[<span class="built_in">bool</span>(<span class="literal">False</span>)]*<span class="number">5</span></span><br><span class="line">b=[<span class="literal">True</span>]*<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="判断字符"><a href="#判断字符" class="headerlink" title="判断字符"></a>判断字符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="string">&quot;1a2b3C&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">if</span> i.isalpha():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;letter&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i.isdigit():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line">fault_vins = <span class="built_in">set</span>() <span class="comment"># &#123;&#125;</span></span><br><span class="line">set_city = &#123;<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;广州&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#遍历</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> thisset:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&quot;北京&quot;</span> <span class="keyword">in</span> thisset</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 用add()方法向集合中添加元素，每次只能添加一个元素</span></span><br><span class="line">set_city.add(<span class="string">&#x27;上海&#x27;</span>)</span><br><span class="line"><span class="comment">#集合是无序的，所以当使用pop()方法时，不知道删除了哪个项。</span></span><br><span class="line">set_city.pop()</span><br><span class="line"><span class="built_in">len</span>(set_city)</span><br><span class="line"><span class="comment"># 转化为set，去重，搜索快</span></span><br><span class="line"><span class="built_in">set</span>(vins)</span><br></pre></td></tr></table></figure>
<h3 id="apply-replace"><a href="#apply-replace" class="headerlink" title="apply(), replace()"></a>apply(), replace()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 年月日</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time2pt</span>(<span class="params">str_time</span>):</span><br><span class="line">    <span class="keyword">return</span> str_time.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>].replace(<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;pt&#x27;</span>] = df[<span class="string">&#x27;采集时间&#x27;</span>].apply(time2pt)</span><br></pre></td></tr></table></figure>
<h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">&#x27;./path/&#x27;</span></span><br><span class="line">file_list = os.listdir(path)</span><br><span class="line"><span class="comment"># 对序列排序</span></span><br><span class="line">file_list.sort()</span><br></pre></td></tr></table></figure>
<h3 id="防止集合或列表在添加元素时更新"><a href="#防止集合或列表在添加元素时更新" class="headerlink" title="防止集合或列表在添加元素时更新"></a>防止集合或列表在添加元素时更新</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(a):</span><br><span class="line">  a.append(i+<span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">  a.append(i+<span class="number">1</span>)</span><br><span class="line"><span class="comment">#无限循环</span></span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><strong>ord()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ord（）函数就是用来返回单个字符的ascii值（0-255）或者unicode数值（）</span></span><br><span class="line"><span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure>
<p><strong>enumerate()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&quot;Alice&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Carl&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;index&#125;</span>: <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="number">0</span>: Alice</span><br><span class="line"><span class="number">1</span>: Bob</span><br><span class="line"><span class="number">2</span>: Carl</span><br></pre></td></tr></table></figure>
<p><strong>map()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#map是python内置函数，会根据提供的函数对指定的序列做映射</span></span><br><span class="line"><span class="comment">#每个元素int</span></span><br><span class="line">t=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">#int类型的 [1,2,3]</span></span><br><span class="line"></span><br><span class="line">t=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment">#[1, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将字符串转换为list</span></span><br><span class="line">t=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="string">&#x27;1234&#x27;</span>) <span class="comment">#[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取字典中的key，并将结果放在一个list中</span></span><br><span class="line"><span class="built_in">map</span>(<span class="built_in">int</span>,&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>,<span class="number">3</span>:<span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><strong>基础数学函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">12.34567889</span></span><br><span class="line"><span class="comment"># 保留一位小数</span></span><br><span class="line"><span class="built_in">round</span>(a,<span class="number">1</span>) <span class="comment">#12.3</span></span><br><span class="line"><span class="built_in">abs</span>()</span><br><span class="line"><span class="built_in">min</span>()</span><br><span class="line"><span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p><strong>bisect_left</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二分搜索</span></span><br><span class="line">nums=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">index=bisect_left(nums,target)</span><br></pre></td></tr></table></figure>
<p><strong>range()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res.append(nums[:])</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">res.append(copy.deepcopy(nums))</span><br></pre></td></tr></table></figure>
<h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"><span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="访问数据库"><a href="#访问数据库" class="headerlink" title="访问数据库"></a>访问数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;10.106.99.171&#x27;</span>, port=<span class="number">9030</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;fs_bigdata@123&#x27;</span>, database=<span class="string">&#x27;fs_bigdata_web&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建游标对象</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&quot;select * from database&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="comment"># 获取所有数据，以元组形式返回</span></span><br><span class="line">data = cursor.fetchall()</span><br><span class="line"><span class="comment"># tuple2dataframe</span></span><br><span class="line">df = pd.DataFrame(<span class="built_in">list</span>(data), columns=[<span class="string">&#x27;&#x27;</span>])</span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<h3 id="图片写入excel"><a href="#图片写入excel" class="headerlink" title="图片写入excel"></a>图片写入excel</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook, load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.drawing.image <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> openpyxl.drawing.spreadsheet_drawing <span class="keyword">import</span> AnchorMarker, TwoCellAnchor</span><br><span class="line"><span class="comment"># 读取excel</span></span><br><span class="line">wb = load_workbook(outputpath)</span><br><span class="line">Ws = wb[<span class="string">&#x27;Sheet1&#x27;</span>]</span><br><span class="line"><span class="comment"># 制定图片目录</span></span><br><span class="line">image_dir = <span class="string">&quot;./&#123;&#125;/&quot;</span>.<span class="built_in">format</span>(pkg)</span><br><span class="line"><span class="comment"># 按excel中vin顺序插入图片</span></span><br><span class="line">vins = output.VIN.to_list()</span><br><span class="line"><span class="comment"># 遍历指定目录中的所有.png图片文件</span></span><br><span class="line"><span class="comment"># for i, filename in enumerate(os.listdir(image dir)):</span></span><br><span class="line"><span class="comment">#   if filename.endswith(&#x27;.png&#x27;):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vins)):</span><br><span class="line">    filename = <span class="string">&#x27;&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(vins[i])</span><br><span class="line">    <span class="comment"># 打开图片</span></span><br><span class="line">    img = Image(os.path.join(image_dir, filename))</span><br><span class="line">    _<span class="keyword">from</span> = AnchorMarker(<span class="number">17</span>, <span class="number">50000</span>, <span class="number">1</span>+<span class="number">1</span>, <span class="number">50000</span>)</span><br><span class="line">    to = AnchorMarker(<span class="number">18</span>, -<span class="number">50000</span>, <span class="number">1</span>+<span class="number">2</span>, -<span class="number">50000</span>)</span><br><span class="line">    img.anchor = TwoCellAnchor(<span class="string">&#x27;twoCell&#x27;</span>, _<span class="keyword">from</span>, to)</span><br><span class="line">    ws.add_image(img)</span><br><span class="line"><span class="comment"># 保存excel</span></span><br><span class="line">wb.save(outputpath)</span><br></pre></td></tr></table></figure>
<h2 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h2><h3 id="画图基础"><a href="#画图基础" class="headerlink" title="画图基础"></a>画图基础</h3><blockquote>
<p>ax作图</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig,ax=plt.subplots(figsize=(<span class="number">15</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># fig, ax = plt.subplots(2,1,figsize(14,7))</span></span><br><span class="line"><span class="comment"># ax[0].***</span></span><br><span class="line"><span class="comment"># ax[1].***</span></span><br><span class="line"></span><br><span class="line">fig.suptitle(<span class="string">&#x27;Main title&#x27;</span>)</span><br><span class="line">fig.tight_layout() <span class="comment">#自动在单元格之间提供足够的填充</span></span><br><span class="line"><span class="comment"># xy坐标轴的标题</span></span><br><span class="line">ax.set_title(<span class="string">&#x27;Title&#x27;</span>,fontsize=<span class="number">18</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;xlabel&#x27;</span>, fontsize=<span class="number">18</span>,fontfamily = <span class="string">&#x27;sans-serif&#x27;</span>,fontstyle=<span class="string">&#x27;italic&#x27;</span>, color=<span class="string">&#x27;blcak&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;ylabel&#x27;</span>, fontsize=<span class="string">&#x27;x-large&#x27;</span>,fontstyle=<span class="string">&#x27;oblique&#x27;</span>, color=<span class="string">&#x27;blcak&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line"><span class="comment"># xy坐标轴的一些属性设定</span></span><br><span class="line">ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax.minorticks_on()</span><br><span class="line">ax.set_xlim(<span class="number">0</span>,<span class="number">16</span>)</span><br><span class="line">ax.grid(which=<span class="string">&#x27;minor&#x27;</span>, axis=<span class="string">&#x27;both&#x27;</span>)</span><br><span class="line"><span class="comment"># 坐标轴tick和细节</span></span><br><span class="line">ax.xaxis.set_tick_params(rotation=<span class="number">45</span>,labelsize=<span class="number">18</span>,colors=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">start, end = ax.get_xlim()</span><br><span class="line">ax.xaxis.set_ticks(np.arange(start, end,<span class="number">1</span>))</span><br><span class="line">ax.yaxis.tick_right() <span class="comment"># 右边tick</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line">ax[<span class="number">0</span>].scatter(x,y, color=<span class="string">&#x27;cornflowerblue&#x27;</span>, s=<span class="number">5</span>, label=<span class="string">&#x27;TBD&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置日期格式</span></span><br><span class="line">ax[<span class="number">0</span>].xaxis.set_major_formatter(mdates.DateFormatter(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)) <span class="comment"># x轴日期格式：pd.to_datetime格式</span></span><br><span class="line"><span class="comment"># 设置日期间隔（此处为7天）</span></span><br><span class="line">ax[<span class="number">0</span>].xaxis.set_major_locator(mdates.DayLocator(interval=<span class="number">7</span>))</span><br><span class="line">ax[<span class="number">0</span>].grid(which=<span class="string">&#x27;major&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">0.5</span>, axis=<span class="string">&#x27;y&#x27;</span>) <span class="comment">#在第一个子图上添加网格</span></span><br><span class="line">ax[<span class="number">0</span>].legend()</span><br><span class="line">ax[<span class="number">0</span>].tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;blcak&#x27;</span>)</span><br><span class="line">ax[<span class="number">0</span>].set_ylim(bottom=<span class="number">0</span>, top=<span class="number">1000</span>)</span><br><span class="line">plt.setp(ax[<span class="number">0</span>].xaxis.get_majorticklables(),rotation=<span class="number">15</span>) <span class="comment">#旋转15度</span></span><br></pre></td></tr></table></figure>
<p>fig: 画布<br>axes: 可以把理解为你要放到画布上的各个物体</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 画n个</span></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>) <span class="comment">#第一幅</span></span><br><span class="line"><span class="comment"># 添加水平线</span></span><br><span class="line">plt.axhline(y=<span class="number">2200</span>, ls=<span class="string">&#x27;--&#x27;</span>, c=<span class="string">&#x27;red&#x27;</span>, lw=<span class="number">2</span>)</span><br><span class="line">plt.hlines(<span class="number">30</span>,xmin=<span class="number">0</span>,xmax=<span class="number">0.001</span>,label=<span class="string">&#x27;vlines&#x27;</span>,color=<span class="string">&#x27;limegreen&#x27;</span>,ls=<span class="string">&#x27;--&#x27;</span>,lw=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 竖直线</span></span><br><span class="line">plt.vline(i,ymin=<span class="number">0</span>,ymax=np.<span class="built_in">max</span>(y),color=<span class="string">&#x27;mediumpurple&#x27;</span>,label=<span class="string">&#x27;vlines&#x27;</span>,ls=<span class="string">&#x27;--&#x27;</span>,lw=<span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># 界限</span></span><br><span class="line">plt.ylim(bottom=-<span class="number">0.5</span>, top=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="画图参数"><a href="#画图参数" class="headerlink" title="画图参数"></a>画图参数</h3><blockquote>
<p>一张图上展示两种曲线</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 防止中文乱码</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 画布大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">30</span>,<span class="number">10</span>))</span><br><span class="line">plt.plot(x,y,color=<span class="string">&#x27;cornflowerblue&#x27;</span>,label=<span class="string">&#x27;volts&#x27;</span>,marker=<span class="string">&#x27;.&#x27;</span>,markersize=<span class="number">3</span>,linewidth=<span class="number">0.8</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;speed&#x27;</span>, fontsize=<span class="number">20</span>, loc=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;orangered&#x27;</span>) <span class="comment"># color=shifts_colors[i%3]循环颜色</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;speed&#x27;</span>)</span><br><span class="line"><span class="comment"># 自定义横轴</span></span><br><span class="line">xlabel = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df), <span class="built_in">int</span>(<span class="built_in">len</span>(df)/<span class="number">30</span>))]</span><br><span class="line">plt.xticks(xlabel, [df.loc[i,<span class="string">&#x27;pt&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(df),<span class="built_in">int</span>(<span class="built_in">len</span>(df)/<span class="number">30</span>))], rotation=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show() <span class="comment"># 不会显示其它乱七八糟的输出</span></span><br><span class="line"><span class="comment"># 导出图片</span></span><br><span class="line">plt.savefig(vin + <span class="string">&#x27;.png&#x27;</span>, dpi=<span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历dataframe</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    balabala</span><br></pre></td></tr></table></figure>
<h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;/路径.csv&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>,header=<span class="number">1</span>) <span class="comment">#第二行作为表头</span></span><br><span class="line"><span class="comment"># 加两列 data.insert(位置，列名，列值)</span></span><br><span class="line">df.insert(<span class="number">4</span>,<span class="string">&#x27;med&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 新df</span></span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">&#x27;vin&#x27;</span>,<span class="string">&#x27;start&#x27;</span>,<span class="string">&#x27;end&#x27;</span>])</span><br><span class="line"><span class="comment"># 新的一行</span></span><br><span class="line">line = pd.DataFrame(&#123;<span class="string">&#x27;sending_time&#x27;</span>:temp,<span class="string">&#x27;vin&#x27;</span>:vin&#125;,index=[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 读excel</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;路径.xlsx&#x27;</span>,sheetname=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"><span class="comment"># 写入excel</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;.xlsx&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">outputpath=<span class="string">&#x27;xxx.csv&#x27;</span></span><br><span class="line">df.to_csv(outputpath,sep=<span class="string">&#x27;,&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 中文</span></span><br><span class="line">output.to_csv(outputpath,encoding=<span class="string">&#x27;utf_8_sig&#x27;</span>,index=<span class="literal">False</span>,header=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.time = pd.to_datetime(df.time)</span><br><span class="line"><span class="comment"># 计算时间差</span></span><br><span class="line">days = (df.loc[<span class="number">0</span>,<span class="string">&#x27;date&#x27;</span>] - df.loc[<span class="number">1</span>,<span class="string">&#x27;date&#x27;</span>]).days</span><br><span class="line">hours = ((df.loc[<span class="number">0</span>,<span class="string">&#x27;date&#x27;</span>] - df.loc[<span class="number">1</span>,<span class="string">&#x27;date&#x27;</span>]).seconds/<span class="number">3600</span> + days*<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Timedelta</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">date + pd.Timedelta(days=-<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h3 id="df元素值是列表"><a href="#df元素值是列表" class="headerlink" title="df元素值是列表"></a>df元素值是列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.[<span class="string">&#x27;temp_units&#x27;</span>].astype(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">df.at[index,<span class="string">&#x27;temp_units&#x27;</span>] = df.loc[index,<span class="string">&#x27;temp_units&#x27;</span>].strip(<span class="string">&#x27;[]&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">df.at[index,<span class="string">&#x27;temp_units&#x27;</span>] = [<span class="built_in">int</span>(x)-<span class="number">40</span> <span class="keyword">for</span> x <span class="keyword">in</span> df.loc[index,<span class="string">&#x27;temp_units&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一串电压提取出列表</span></span><br><span class="line">volts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df)):</span><br><span class="line">    volts.append([<span class="built_in">float</span>(t) <span class="keyword">for</span> t <span class="keyword">in</span> df.loc[i,<span class="string">&#x27;单体电池信息&#x27;</span>].strip(<span class="string">&#x27;\t[]&#x27;</span>).split(<span class="string">&#x27;;&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<h3 id="df中定位"><a href="#df中定位" class="headerlink" title="df中定位"></a>df中定位</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#iloc按照索引值来定位数据元素，loc是按照标签值来定位元素</span></span><br><span class="line">df.loc[i,<span class="string">&#x27;speed&#x27;</span>]</span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">keep = [<span class="number">1</span>,<span class="number">24</span>,<span class="number">6</span>]</span><br><span class="line">df.iloc[keep]</span><br><span class="line"><span class="comment"># 取某特定值的所有行</span></span><br><span class="line">lines = df[(df[<span class="string">&#x27;vin&#x27;</span>]==vin)&amp;(df[<span class="string">&#x27;timestamp&#x27;</span>]&lt;end)].reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除dataframe指定行列</span></span><br><span class="line">row_index = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">df.drop(row_index,inplace=<span class="literal">True</span>) <span class="comment"># axis=0</span></span><br><span class="line"><span class="comment"># 列</span></span><br><span class="line">df.drop(<span class="string">&#x27;vin&#x27;</span>, axis=<span class="number">1</span>,inplace=<span class="literal">True</span>) <span class="comment">#columns=column_label</span></span><br><span class="line"><span class="comment">#重置索引</span></span><br><span class="line">df.reset_index(drop=<span class="literal">True</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>(df.iloc[:,<span class="number">15</span>]) <span class="comment">#某一列中的最大值</span></span><br><span class="line">df.iloc[:,<span class="number">15</span>：].<span class="built_in">max</span>() <span class="comment">#多列分别的最大值</span></span><br><span class="line">df.iloc[:,<span class="number">15</span>：].<span class="built_in">max</span>().<span class="built_in">max</span>() <span class="comment">#多列中的最大值</span></span><br></pre></td></tr></table></figure>
<h3 id="排序，处理空值，重复值"><a href="#排序，处理空值，重复值" class="headerlink" title="排序，处理空值，重复值"></a>排序，处理空值，重复值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns=[<span class="string">&#x27;vin&#x27;</span>, <span class="string">&#x27;speed&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">df.sort_values(by = [<span class="string">&#x27;vin&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>], ascending=<span class="literal">True</span>, ignore_index= <span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">df.isnull()</span><br><span class="line">df = dataset.dropna()</span><br><span class="line">df.dropna(subset = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;born&#x27;</span>])</span><br><span class="line">df.isnull().<span class="built_in">sum</span>()/<span class="built_in">len</span>(df)</span><br><span class="line"><span class="comment"># 去重</span></span><br><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;vin&#x27;</span>], keep=<span class="string">&#x27;first&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># unique()</span></span><br><span class="line">types_car = df[<span class="string">&#x27;项目名称&#x27;</span>].unique()</span><br></pre></td></tr></table></figure>
<h3 id="Pandas函数"><a href="#Pandas函数" class="headerlink" title="Pandas函数"></a>Pandas函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span>() <span class="comment"># 计算总和（按列）</span></span><br><span class="line">mean()</span><br><span class="line">var() <span class="comment"># 方差</span></span><br><span class="line">std() <span class="comment"># 标准差</span></span><br><span class="line">corr() <span class="comment"># 相关系数矩阵</span></span><br><span class="line">cov() <span class="comment"># 协方差矩阵</span></span><br><span class="line">skew() <span class="comment"># 偏度（三阶矩）</span></span><br><span class="line">kurt() <span class="comment"># 峰度（四阶矩）</span></span><br><span class="line">describe() <span class="comment"># 基本描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分位数</span></span><br><span class="line">lines[<span class="string">&#x27;speed&#x27;</span>].quantile(<span class="number">.5</span>)</span><br><span class="line">pd.DataFrame(lines[<span class="string">&#x27;speed&#x27;</span>].quantile([<span class="number">0.5</span>,<span class="number">0.97</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分类</span></span><br><span class="line">sc = df.groupby([<span class="string">&#x27;vin&#x27;</span>]).count()</span><br><span class="line">vins = sc.index.values <span class="comment"># 列出所有vin 等同于df.vin.unique()</span></span><br><span class="line"></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;car_type&#x27;</span>)</span><br><span class="line">average_temperature = grouped[<span class="string">&#x27;socs&#x27;</span>].mean() <span class="comment"># 分类后，各类别下的平均soc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># to_dict()转化为字典</span></span><br><span class="line">info_summary = df.groupby(<span class="string">&#x27;car_type&#x27;</span>).count()[<span class="string">&#x27;vin&#x27;</span>].to_dict()</span><br><span class="line">x = <span class="built_in">list</span>(info_summary.keys()) <span class="comment"># 统计车型</span></span><br><span class="line">y = <span class="built_in">list</span>(info_summary.values()) <span class="comment"># 统计数量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">third = pd.concat([first,second],ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 连接两个df</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    file_name = <span class="string">&#x27;vin &#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27;.csv&#x27;</span></span><br><span class="line">    df = pd.read_csv(file_name, encoding = <span class="string">&#x27;gbk&#x27;</span>) <span class="comment"># gb18030 中文不乱码</span></span><br><span class="line">    output = pd.concat([output,df])</span><br></pre></td></tr></table></figure>
<h3 id="创建DataFrame表格"><a href="#创建DataFrame表格" class="headerlink" title="创建DataFrame表格"></a>创建DataFrame表格</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. 用列表来创建</span></span><br><span class="line">data = [[第一行的第一列值,第一行的第二列值],[第二行的第一列值,第二行的第二列值]]</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;列名&#x27;</span>,<span class="string">&#x27;列名&#x27;</span>])</span><br><span class="line"><span class="comment"># 创建空df</span></span><br><span class="line">columns = [<span class="string">&#x27;car_type&#x27;</span>] + <span class="built_in">list</span>(df[<span class="string">&#x27;warn_type&#x27;</span>].unique())</span><br><span class="line">df = pd.DataFrame([], columns = columns)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 用字典dict来创建</span></span><br><span class="line">data = [&#123;key1：value1&#125;, &#123;key2：value2&#125;, &#123;key3：value3&#125;]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 用ndarrays创建</span></span><br><span class="line">data = &#123;<span class="string">&#x27;columns_1&#x27;</span>:[values1],</span><br><span class="line">     <span class="string">&#x27;columns_2&#x27;</span>:[values2]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line">data = df.copy(deep=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array(volts).T  <span class="comment"># 转置</span></span><br><span class="line">np.array().reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.sort() <span class="comment"># 对输入数组执行排序，并返回一个排序好的数组副本；</span></span><br><span class="line">numpy.argsort() <span class="comment"># 对输入数组的元素值进行排序，并返回排序后的元素索引数组；</span></span><br><span class="line">numpy.where() <span class="comment"># 的返回值是满足了给定条件的元素索引值；</span></span><br><span class="line">numpy.nonzero() <span class="comment"># 该函数从数组中查找非零元素的索引位置；</span></span><br><span class="line"><span class="comment">#最小值索引</span></span><br><span class="line">np.argmin(array)</span><br><span class="line"><span class="comment">#平均数</span></span><br><span class="line">np.mean()</span><br><span class="line"><span class="comment"># 排序索引</span></span><br><span class="line">np.argsort(array)[num] <span class="comment">#num==-1,输出最大值对应的index, num==:5,输出最大的5个值</span></span><br><span class="line"><span class="comment">#倒序 [::-1]</span></span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title></a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Learning</title>
    <url>/2022/08/16/Deep-Learning/</url>
    <content><![CDATA[<h4 id="the-rise-of-deep-learning"><a href="#the-rise-of-deep-learning" class="headerlink" title="the rise of deep learning"></a>the rise of deep learning</h4><ul>
<li>Better algorithms(e.g. dropout, batch normalization, etc.)</li>
<li>Better hardware(high performing GPU) &#x2F; we have access to a lot more computational power.</li>
<li>More data to train &#x2F; we have access to a lot more data</li>
</ul>
<h4 id="difference-between-CNN-and-RNN"><a href="#difference-between-CNN-and-RNN" class="headerlink" title="difference between CNN and RNN"></a>difference between CNN and RNN</h4><ul>
<li>CNN’s work really well for computer vision. RNN’s are really good for natural languate processing.</li>
<li>In CNN, the network takes fixed-size inputs and generates fixed size outputs. RNN can handle arbitrary input&#x2F; out lengths.</li>
<li>CNN saves a set of weights and applies them spatially. Whereas, RNN saves a set of wights and applies them temporally.</li>
<li>CNN is used for spatial data like images. Whereas, RNN is more suitable for sequence modeling, i.e. series.</li>
</ul>
<h4 id="Reinforcement-Learning-RL"><a href="#Reinforcement-Learning-RL" class="headerlink" title="Reinforcement Learning(RL)"></a>Reinforcement Learning(RL)</h4><p>RL enables the agents to learn to take appropriate action based on external environment, internal state, and reward for action.</p>
<h4 id="Stochastic-Gradient-Descent-SGD-and-Batch-Gradient-Descent"><a href="#Stochastic-Gradient-Descent-SGD-and-Batch-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent(SGD) and Batch Gradient Descent"></a>Stochastic Gradient Descent(SGD) and Batch Gradient Descent</h4><p>为了获取准确的梯度，批量梯度下降法的每一 步都把整个训练集载入进来进行计算，时间花费和内存开销都非常大，无法应用于大数据集、大模型的场景。相反，随机梯度下降法则放弃了对梯度准确性的追求，每步仅仅随机采样一个(或少量)样本来估计当前梯度，计算速度快，内存开销小。但由于每步接受的信息量有限，随机梯度下降法对梯度的估计常常出现偏差，造成目标函数曲线收敛得很不稳定，伴有剧烈波动，有时甚至出现不收敛的情况。</p>
<h4 id="Momentum-AdaGrad-Adam"><a href="#Momentum-AdaGrad-Adam" class="headerlink" title="Momentum, AdaGrad, Adam"></a>Momentum, AdaGrad, Adam</h4><ul>
<li>Adagrad adjusts the learning rate based on historical information<br>• Frequently occurring features in the gradients get small learning rates and<br>infrequent features get higher ones<br>• Key idea: “learn slowly” from frequent features but “pay attention” to rare but<br>informative features</li>
</ul>
<h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p>它是二分类函数sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。</p>
<ol>
<li>降预测结果转化为非负数</li>
<li>各种预测结果概率之和等于1</li>
</ol>
<p>backpropagation:recursive application of the chain rule along a computational graph to compute the gradients of all inputs&#x2F;parameters&#x2F;intermediates<br>• forward: compute result of an operation and save any intermediates needed for<br>gradient computation in memory<br>• backward: apply the chain rule to compute the gradient of the loss function<br>with respect to the inputs</p>
<p>Random Initialization<br>• Important to randomize initial weight matrices<br>• Can’t have uniform initial weights, as in logistic regression. Otherwise, all updates will be identical &amp; the net won’t learn</p>
<p>Training a Neural Network</p>
<ol>
<li>Randomly initialize weights</li>
<li>Implement forward propagation to get hΘ(xi) for any instance xi</li>
<li>Implement code to compute cost function J(Θ)</li>
<li>Implement backprop to compute partial derivatives</li>
<li>Use gradient checking to compare computed using backpropagation vs. the numerical gradient estimate.<br>• Then, disable gradient checking code</li>
<li>Use gradient descent with backprop to fit the network</li>
</ol>
<blockquote>
<p>Multilayer Perceptron<br>• A multilayer perceptron is a special case of a feedforward neural<br>network, where every layer is a fully connected layer</p>
</blockquote>
<p>Why Convolution?</p>
<ul>
<li>ReLU<br>very fast computation<br>most common activation function<br>piecewise linear</li>
<li>tanh<br>“hyperbolic tangent”, often pronounced like “tanch”<br>Smoothes out discontinuities<br>used to be more popular, replaced by ReLU</li>
<li>logistic sigmoid<br>similar to tanh. Used rarely nowadays</li>
</ul>
<p>Softmax<br>• Applied to an entire vector, not component-wise.<br>• Normalizes a vector. Entries of the output sum to 1.<br>• The most common way to predict a probability distribution.<br>• Typically used in the final layer of networks for classification tasks.</p>
<p><strong>Dropout</strong><br>• Prevents overfitting by preventing co-adaptations<br>• Forces “dead branches” to learn<br>Forces the network to have a redundant representation; prevents co-adaptation of features</p>
<p>• Randomly select weights to update<br>• More precisely, in each update step<br> • Randomly sample a different binary mask to all the input and hidden units<br> • Multiple the mask bits with the units and do the update as usual<br>• Typical dropout probability: 0.2 for input and 0.5 for hidden units</p>
<p><strong>RNN(Recurrent Neural Networks)</strong><br>• Use <strong>the same</strong> computational function and parameters across different time steps of the sequence<br>• Each time step: takes the input entry and <strong>the previous hidden state</strong> to compute the output entry<br>• Loss: typically computed at every time step</p>
<p><strong>Batch Normalization</strong><br>Usually inserted after Fully Connected or Convolutional layers, and before nonlinearity<br>• Improves gradient flow through the network<br>• Allows higher learning rates<br>• Reduces the strong dependence on initialization<br>• Acts as a form of regularization in a funny way, and slightly reduces the need for dropout, maybe</p>
<p><strong>Advantages of Naïve Bayes</strong><br>• Based on the independent assumption<br>• A small amount of training data to estimate parameters (means and variances of the variable)<br>• Only the variances of variables for each class need to be determined and not the entire covariance matrix<br>• Test is straightforward; just looking up tables or calculating conditional probabilities with normal distribution</p>
<p><strong>Why Generative Models?</strong><br>• Excellent test of our ability to use high-dimensional and complicated probability distributions<br>• Simulate possible futures for planning or simulated RL<br>• Generating more data or missing data<br> • Semi-supervised learning<br>• Multi-modal outputs<br>• Realistic generation tasks</p>
<p><strong>Why GANs?</strong><br>• Sampling (or generation) is straightforward.<br>• Training doesn’t involve Maximum Likelihood estimation.<br>• Robust to Overfitting since Generator never sees the training data.<br>• Empirically, GANs are good at capturing the modes of the distribution.</p>
<p><strong>Problems with GANs</strong><br>• Probability Distribution is Implicit<br> • Not straightforward to compute P(X).<br> • Thus Vanilla GANs are only good for Sampling&#x2F;Generation.<br>• Training is Hard<br> • Non-Convergence<br> • Mode-Collapse</p>
<p><strong>Mode-Collapse</strong><br>• Perhaps the most challenging model failure is the case where multiple inputs to the generator result in the generation of the same output. This is referred to as mode-collapse, and may represent one of the most challenging issues when training GANs<br>• Problem that occurs when the generator learns to map several different input z values to the same output point.<br>• One intuitive metric of performance can be obtained by having human annotators judge the visual quality of samples</p>
<p><strong>How To Train a GAN?</strong></p>
<ul>
<li>Use a Gaussian Latent Space<br> • Sample from a standard Gaussian distribution, meaning that the shape of the latent space is a hypersphere, with a mean of zero and a standard deviation of one</li>
<li>Separate Batches of Real and Fake Images<br> • The discriminator model is trained using SGD with mini-batches<br> • The best practice is to update the discriminator with separate batches of real and fake images rather than combining real and fake images into a single batch</li>
<li>Use Label Smoothing<br> • Using the class label 1 for real images and 0 for fake images when training the discriminator model is common. These are hard labels<br> • Also use soft labels, such as values slightly more or less than 1.0 or slightly more than 0.0 for real and fake images respectively, where the variation for<br>each image is random. This is often referred to as label smoothing and can have a regularizing effect when training the model</li>
<li>Use Noisy Labels<br> • Introduce some errors to the labels, where some fake images are marked as real, and some real images are marked as fake</li>
</ul>
<p>(N-F)&#x2F;stride+1</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System</title>
    <url>/2022/08/13/Operating-System/</url>
    <content><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p>
<p>🙋 <strong>我</strong> ：死锁描述的是这样一种情况：多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p>
<h4 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h4><p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>
<p>🙋 <strong>我</strong> ：如果系统中以下四个条件同时成立，那么就能引起死锁：</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>注意，只有四个条件同时成立时，死锁才会出现。</p>
<h4 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h4><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li><p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p>
</li>
<li><p><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>
</li>
<li><p><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>
</li>
<li><p><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</p>
</li>
</ul>
<h5 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h5><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>1、静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>2、层次分配策略</strong></p>
<p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>银行家算法详情可见：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》</a> 。</p>
<p>操作系统教程树中讲述的银行家算法也比较清晰，可以一看.</p>
<p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>R</title>
    <url>/2022/09/22/R/</url>
    <content><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>无序列表<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span>观点<span class="number">1</span></span><br><span class="line"><span class="operator">*</span>观点<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>有序列表<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 观点<span class="number">1</span></span><br><span class="line"><span class="number">2.</span> <span class="operator">*</span>观点<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span>加粗<span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">*</span>斜体<span class="operator">*</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>加粗且斜体<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="punctuation">[</span>链接<span class="punctuation">]</span><span class="punctuation">(</span>https<span class="operator">:</span><span class="operator">/</span><span class="operator">/</span>taihangli.github.io<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2022/08/12/Python/</url>
    <content><![CDATA[<p><strong>6种内建序列</strong>: 列表(list), 元组(tuple), 字符串, Unicode字符串, buffer对象, xrange对象<br><strong>7种序列操作</strong>: 索引(indexing),分片(sliceing), 加(adding), 乘(multiplying), 检查某个元素是否属于这个序列, 计算序列长度(len), 找出最大和最小元素(max&#x2F;min)</p>
<blockquote>
<p>列表和元组的区别</p>
</blockquote>
<ul>
<li>相同点：<br>1、均具有序列的特性，均可以进行序列通用的操作；<br>2、通常均使用括号表示，且括号内的元素以逗号分隔值出现，数据项均不需要具有相同的类型；<br>3、均包含内置函数max、min、len<br>4、均可以转换为对方</li>
<li>不同点：</li>
</ul>
<ol>
<li>定义不同<br>1）列表使用方括号括起来的。<br>2）元组使用小括号括起来的。</li>
<li>是否可修改<br>1）列表可修改<br>2）元组不可修改</li>
<li>转换方式<br>1）列表转元组：tuple(seq)<br>2）元组转列表： list(seq)</li>
<li>是否含内置方法<br>1）列表提供11个内置方法<br>2）元组未提供内置方法</li>
</ol>
<ul>
<li>List 是一个有序且可修改的集合。允许有重复的成员。</li>
<li>Tuple 是一个有序且不可更改的集合。允许有重复的成员。</li>
<li>Set 是一个无序且无索引的集合。没有重复的成员。</li>
<li>Dictionary 是一个无序的、可修改的、有索引的集合。没有重复的成员。</li>
</ul>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>有两种产生生成器对象的方式：一种是列表生成式加括号：</p>
<blockquote>
<p>g1 &#x3D; (x for x in range(10))</p>
</blockquote>
<p>一种是在函数定义中包含yield关键字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line">g2 = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>对于generator对象g1和g2，可以通过next(g1)不断获得下一个元素的值，如果没有更多的元素，就会报错 <em>StopIteration</em> ，也可以通过for循环获得元素的值。<br>生成器的好处是不用占用很多内存，只需要在用的时候计算元素的值就行了。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Python中可以用于for循环的，叫做可迭代Iterable，包括list&#x2F;set&#x2F;tuple&#x2F;str&#x2F;dict等数据结构以及生成器；可以用以下语句判断一个对象是否是可迭代的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(x, Iterable)</span><br></pre></td></tr></table></figure>
<p>迭代器Iterator，是指可以被next()函数调用并不断返回下一个值，直到StopIteration；生成器都是Iterator，而列表等数据结构不是；可以通过以下语句将list变为Iterator：</p>
<blockquote>
<p>iter([1,2,3,4,5])</p>
</blockquote>
<p>生成器都是Iterator，但迭代器不一定是生成器。</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ol>
<li>读取 csv文件。用到pandas库中的read_csv()<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">csv_data= pd.read_csv(<span class="string">&#x27;/路径/文件名.csv/&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>读取txt文件。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;路径/文件名.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#readlines()</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines=f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这个函数将文件所用内容以行为区分读到一个列表中 ，列表中的每一个元素是一行；lines是list，line 是str。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#readline()</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line =f.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        line=f.readline()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这种方式是一行一行的读，非常的省内存，当文件巨大的情况下是有好处的</li>
<li>读取excel文件。用到xlrd库（pip install xlrd安装，导入模块import xlrd）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line">data=xlrd.open_workbook(<span class="string">r&#x27;\路径\文件名.xlsx&#x27;</span>,formatting_info=<span class="literal">True</span>)</span><br><span class="line">table =data.sheet_by_name(<span class="string">&#x27;Sheet3&#x27;</span>)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_excel(<span class="string">&quot;\路径\文件名.xlsx&quot;</span>,sheetname=<span class="string">&#x27;Sheet3&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>拼接函数</strong><br>join()方法、concat() 方法和merge()方法都是属于pandas库中的拼接函数；concatenate()方法属于numpy库中的拼接的方法，除此之外numpy库中拼接的方法还有np.append() 、np.stack()、 np. Hstack()、np.vstack()和np.vstack()等操作</p>
<p><strong>to_numberic(arg,errors,downcast)</strong><br>errors存在三个参数{‘ignore’，’raise’，’coerce’}，默认情况下为’raise’。如果为“ raise”，则无效的解析将引发异常；如果为“强制”，则无效的解析将设置为NaN；如果为“ ignore”，则无效的解析将返回输入。downcast &#x3D;’signed’所有值都将转换为整型。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>My First Post</title>
    <url>/2022/06/19/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>Welcome to <a href="https://taihangli.github.io/">Tiger’ Home</a>! This is my very first post.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Post-a-new-blog"><a href="#Post-a-new-blog" class="headerlink" title="Post a new blog"></a>Post a new blog</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo d -g</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2022/08/12/markdown/</url>
    <content><![CDATA[<p>Markdown笔记（来自Joy）</p>
<h2 id="自定义文字"><a href="#自定义文字" class="headerlink" title=" 自定义文字"></a><font color="6FBCE1"> 自定义文字</font></h2><p>`我是高亮`<br><code>我是高亮</code></p>
<p>**粗体**<br> __粗体__<br><strong>粗体</strong></p>
<p>*斜体*<br>_斜体_<br><em>斜体</em></p>
<p><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del></p>
<p>- aa<br>- bb<br>  - bb.1<br>  - bb.2<br>- cc\</p>
<ul>
<li>aa</li>
<li>bb<ul>
<li>bb.1</li>
<li>bb.2</li>
</ul>
</li>
<li>cc</li>
</ul>
<p>\1. aa<br>\2. bb<br>\3. cc</p>
<ol>
<li>aa</li>
<li>bb</li>
<li>cc</li>
</ol>
<p>&lt;!– comment –&gt;<br>快捷键 command + &lt;- + &#x2F;</p>
<p>快捷键 command + d find all same object</p>
<p>&gt; 引用了一段名人名言。</p>
<blockquote>
<p>引用了一段名人名言。</p>
</blockquote>
<p>&gt; 曾经沧海难为水<br>除却巫山不是云\</p>
<blockquote>
<p>曾经沧海难为水<br>除却巫山不是云</p>
</blockquote>
<p>\&gt; 我不再是引用。</p>
<p>- [x] 已经做完的事情</p>
<ul>
<li><input checked disabled type="checkbox"> 已经做完的事情</li>
</ul>
<p>- [ ] 还没做的事情</p>
<ul>
<li><input disabled type="checkbox"> 还没做的事情</li>
</ul>
<p><kbd>Create Project</kbd></p>
<p>[这个是链接](<a href="http://www.baidu.com/">http://www.baidu.com/</a>)<br><a href="http://www.baidu.com/">这个是链接</a></p>
<p>下面这个是图片：</p>
<p>&lt;img src&#x3D;”<a href="http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg">http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg</a>“ width&#x3D;256 height&#x3D;256 &#x2F;&gt;</p>
<img src="http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg" width="256" height="256">

<p>!<a href="tcp-shakes-hands-three-times.png"></a><br><img src="/2022/08/12/markdown/tcp-shakes-hands-three-times.png"></p>
<p>!<a href="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png">TCP 三次握手图解</a></p>
<p>![这样就是图片](<a href="http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg">http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg</a>)</p>
<p><img src="http://y.gtimg.cn/music/photo_new/T002R300x300M000000C4fZU14IubU_1.jpg" alt="这样就是图片"></p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>成绩</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>AAA</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>BBB</td>
<td>98</td>
</tr>
<tr>
<td>3</td>
<td>CCC</td>
<td>59</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
<tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
</tbody></table>
<p>第二行分割表头和内容。</p>
<ul>
<li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li>
</ul>
<ol>
<li>第一条</li>
<li>第二条<blockquote>
<p>第二条很重要。</p>
</blockquote>
</li>
<li>第三条</li>
</ol>
<p>一起来玩捉迷藏。</p>
<details>
<summary>我在哪里？</summary>

<blockquote>
<p>被你发现了。</p>
</blockquote>
</details>

<p>$\vartheta$</p>
<p>&amp;nbsp;<br>空格</p>
<p>&lt;br&#x2F;&gt;<br><br>下一行<br>&lt;center&gt; 居中 </p>
<center> 居中 </center>

<p>&lt;font color&#x3D; 977FD7&gt; 紫色&lt;&#x2F;font&gt;<br><font color="977FD7"> 紫色</font></p>
<p>&lt;font color&#x3D; 6FBCE1&gt; 蓝色&lt;&#x2F;font&gt;<br><font color="6FBCE1"> 蓝色</font></p>
<p>&lt;font color&#x3D; E675A7&gt; 粉色&lt;&#x2F;font&gt;<br><font color="E675A7"> 粉色</font></p>
<p>&lt;font color&#x3D; FC572B&gt; 红色&lt;&#x2F;font&gt;<br><font color="FC572B"> 红色</font></p>
<p>&lt;font color&#x3D;#2E86C1 size&#x3D;2 face&#x3D;”klee”&gt;蓝色特定大小字体&lt;/font&gt;<br><font color="#2E86C1" size="2" face="klee">蓝色特定大小字体</font></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line">printf(<span class="string">&quot;%d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure>
<h2 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h2><p>加粗<br>倾斜<br>倾斜加粗<br>删除线<br>下划线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<p>效果：<br><strong>这是加粗的文字</strong></p>
<p><em>这是倾斜的文字</em></p>
<p><em><strong>这是斜体加粗的文字</strong></em></p>
<p><del>这是加删除线的文字</del></p>
<p><u>这是下划线</u></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#x27;图片title&#x27;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p><img src="/2022/08/12/markdown/assets/img/cat.jpg" alt="图片alt" title="图片title"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果上线到blog</span><br><span class="line">![图片alt](/assets/img/cat.jpg &#x27;图片title&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line">如：[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><a href="http://baidu.com/">百度</a></p>
<h2 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字加点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<h2 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<table>
<thead>
<tr>
<th>表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
<tr>
<td>内容</td>
<td align="center">内容</td>
<td align="right">内容</td>
</tr>
</tbody></table>
<h2 id="九-代码"><a href="#九-代码" class="headerlink" title="九.代码"></a>九.代码</h2><p>单行代码:<br><code>单行内容</code><br>代码块：<br>(<code>) (</code>)</p>
<h2 id="Customizing-Text-with-Markdown"><a href="#Customizing-Text-with-Markdown" class="headerlink" title=" Customizing Text with Markdown"></a><font color="977FD7"> Customizing Text with Markdown</font></h2><h3 id="Headings"><a href="#Headings" class="headerlink" title=" Headings"></a><font color="6FBCE1"> Headings</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is the highest level of the text.</span><br><span class="line">## This is the second highest level of the text.</span><br><span class="line">### Each hash mark creates a new level of text for headers.</span><br><span class="line">#### These are useful for subsections for large chunks of information.</span><br><span class="line">##### There are six different headers you can use for text.</span><br><span class="line">###### This is sixth section!</span><br></pre></td></tr></table></figure>
<h1 id="This-is-the-highest-level-of-the-text"><a href="#This-is-the-highest-level-of-the-text" class="headerlink" title="This is the highest level of the text."></a>This is the highest level of the text.</h1><h2 id="This-is-the-second-highest-level-of-the-text"><a href="#This-is-the-second-highest-level-of-the-text" class="headerlink" title="This is the second highest level of the text."></a>This is the second highest level of the text.</h2><h3 id="Each-hash-mark-creates-a-new-level-of-text-for-headers"><a href="#Each-hash-mark-creates-a-new-level-of-text-for-headers" class="headerlink" title="Each hash mark creates a new level of text for headers."></a>Each hash mark creates a new level of text for headers.</h3><h4 id="These-are-useful-for-subsections-for-large-chunks-of-information"><a href="#These-are-useful-for-subsections-for-large-chunks-of-information" class="headerlink" title="These are useful for subsections for large chunks of information."></a>These are useful for subsections for large chunks of information.</h4><h5 id="There-are-six-different-headers-you-can-use-for-text"><a href="#There-are-six-different-headers-you-can-use-for-text" class="headerlink" title="There are six different headers you can use for text."></a>There are six different headers you can use for text.</h5><h6 id="This-is-sixth-section"><a href="#This-is-sixth-section" class="headerlink" title="This is sixth section!"></a>This is sixth section!</h6><h3 id="Styling-Text"><a href="#Styling-Text" class="headerlink" title=" Styling Text"></a><font color="6FBCE1"> Styling Text</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**This text is bold.**</span><br><span class="line">*This text is in italics.* _This text is also in italics._</span><br><span class="line">~~This text has a strike-through applied.~~</span><br><span class="line">~~**What if something is really important gets crossed out?**~~</span><br><span class="line">_**It&#x27;s pretty easy to ~~apply~~ multiple styles.**_</span><br></pre></td></tr></table></figure>
<p>**This text is bold.**<br><em>This text is in italics.</em> _This text is also in italics._<br><del>This text has a strike-through applied.</del><br><del><strong>What if something is really important gets crossed out?</strong></del><br>_<strong>It’s pretty easy to <del>apply</del> multiple styles.</strong>_\</p>
<h3 id="Quoting-Text"><a href="#Quoting-Text" class="headerlink" title=" Quoting Text"></a><font color="6FBCE1"> Quoting Text</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; I body him.</span><br><span class="line">&gt;&gt; There&#x27;s gonna come a point where you&#x27;ll forget about what</span><br><span class="line">happened and you&#x27;re gonna wanna come back at me.</span><br><span class="line">&gt;&gt;&gt; Don&#x27;t get hit</span><br><span class="line">&gt;&gt;&gt;&gt; SERIOUSLY, don&#x27;t get hit.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; These keep nesting at 20. I stopped checking after that point.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>I body him.</p>
<blockquote>
<p>There’s gonna come a point where you’ll forget about what happened and you’re gonna wanna come back at me.</p>
<blockquote>
<p>Don’t get hit</p>
<blockquote>
<p>SERIOUSLY, don’t get hit.</p>
<blockquote>
<p>These keep nesting at 20. I stopped checking after that point.</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title=" Code"></a><font color="6FBCE1"> Code</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``</span><br><span class="line">6XQS8-KLKEH-FTB</span><br><span class="line">STCBW-2V6V6-9D4</span><br><span class="line">``</span><br><span class="line">The lobby code is `weloveesports`!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6XQS8-KLKEH-FTB</span><br><span class="line">STCBW-2V6V6-9D4</span><br></pre></td></tr></table></figure>

<p>The lobby code is <code>weloveesports</code>!</p>
<h3 id="Lists-and-Bullets"><a href="#Lists-and-Bullets" class="headerlink" title=" Lists and Bullets"></a><font color="6FBCE1"> Lists and Bullets</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### shopping list pt 1</span><br><span class="line">* allen wrenches</span><br><span class="line">* gerbil feeders</span><br><span class="line"></span><br><span class="line">*********</span><br><span class="line">#### shopping list pt 2</span><br><span class="line">1. Walkie-talkies</span><br><span class="line">- copper wires safety goggles</span><br><span class="line">- radial tires</span><br><span class="line"></span><br><span class="line">*********</span><br><span class="line">#### shopping list pt 3</span><br><span class="line">* Picture hangers</span><br><span class="line">	* paper cutters</span><br><span class="line">		* waffle irons</span><br></pre></td></tr></table></figure>

<h4 id="shopping-list-pt-1"><a href="#shopping-list-pt-1" class="headerlink" title="shopping list pt 1"></a>shopping list pt 1</h4><ul>
<li>allen wrenches</li>
<li>gerbil feeders</li>
</ul>
<hr>
<h4 id="shopping-list-pt-2"><a href="#shopping-list-pt-2" class="headerlink" title="shopping list pt 2"></a>shopping list pt 2</h4><ol>
<li>Walkie-talkies</li>
</ol>
<ul>
<li>copper wires safety goggles</li>
<li>radial tires</li>
</ul>
<hr>
<h4 id="shopping-list-pt-3"><a href="#shopping-list-pt-3" class="headerlink" title="shopping list pt 3"></a>shopping list pt 3</h4><ul>
<li>Picture hangers<ul>
<li>paper cutters<ul>
<li>waffle irons</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Aligning-Text"><a href="#Aligning-Text" class="headerlink" title=" Aligning Text"></a><font color="6FBCE1"> Aligning Text</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div align=&quot;center&quot;&gt;The derogatory term ... win.&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div align=&quot;right&quot;&gt;Now, everyone begins ... win.&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<div align="center">The derogatory term “scrub” means several different things. One definition is someone (especially a game player) who is not good at something (especially a game). By this definition, we all start out as scrubs, and there is certainly no shame in that. I mean the term differently, though. A scrub is a player who is handicapped by self-imposed rules that the game knows nothing about. A scrub does not play to win.</div>

<div align="right">Now, everyone begins as a poor player—it takes time to learn a game to get to a point where you know what you’re doing. There is the mistaken notion, though, that by merely continuing to play or “learn” the game, one can become a top player. In reality, the “scrub” has many more mental obstacles to overcome than anything actually going on during the game. The scrub has lost the game even before it starts. He’s lost the game even before deciding which game to play. His problem? He does not play to win.</div>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/2022/09/23/SQL/</url>
    <content><![CDATA[<ul>
<li>describe<br>用于查看特定表的详细设计信息</li>
<li>show columns<br>查看数据库中表的列名</li>
<li>OVER<br>OVER()函数不能单独使用，必须跟在排名函数（ ROW_NUMBER、DENSE_RANK、RANK、NTILE） 或5种聚合函数（SUM、MAX、MIN、AVG、COUNT）后边。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OVER</span>( [ <span class="keyword">PARTITION</span> <span class="keyword">BY</span> … ] [ <span class="keyword">ORDER</span> <span class="keyword">BY</span> … ] )</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="join和union的区别"><a href="#join和union的区别" class="headerlink" title="join和union的区别"></a>join和union的区别</h4><p>join 是两张表做交连后里面条件相同的部分记录产生一个记录集<br>union是产生的两个记录集(字段要一样的)并在一起，成为一个新的记录集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> table1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table1 </span><br><span class="line"><span class="keyword">JOIN</span> table2 </span><br><span class="line"><span class="keyword">ON</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>
<h4 id="四大排名函数"><a href="#四大排名函数" class="headerlink" title="四大排名函数"></a>四大排名函数</h4><ol>
<li>ROW_NUMBER()<br>排名是序号 连续 不重复，即使遇到表中的两个一样的数值亦是如此<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">row_number</span>() <span class="keyword">OVER</span>(<span class="keyword">order</span> <span class="keyword">by</span> sth <span class="keyword">DESC</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> </span><br></pre></td></tr></table></figure></li>
<li>RANK()<br>把要求排序的值相同的归为一组且每组序号一样，排序序号不连续 1 1 3 4 4 6<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">rank</span>() <span class="keyword">OVER</span>(<span class="keyword">order</span> <span class="keyword">by</span> sth <span class="keyword">ASC</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure></li>
<li>DENSE_RANK()<br>排序是连续的，也会把相同的值分为一组且每组排序号一样<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">dense_rank</span>() <span class="keyword">OVER</span>(<span class="keyword">order</span> <span class="keyword">by</span> sth ) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure></li>
<li>NTILE()<br>Ntile(group_num) 将所有记录分成group_num个组，每组序号一样<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">ntile</span>(<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">order</span> <span class="keyword">by</span> sth ) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote>
<p>IF</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(sva<span class="operator">=</span><span class="number">1</span>,&quot;男&quot;,&quot;女&quot;) <span class="keyword">AS</span> s <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> sva <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LIMIT</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">limit <span class="number">0</span>,<span class="number">1</span> <span class="comment">-- 表示第一条数据(计算是从0开始的)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Computer Basics</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
